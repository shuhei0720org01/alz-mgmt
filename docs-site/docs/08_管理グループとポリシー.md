# Chapter 08: 管理グループとポリシー

このChapterでは、Azure Landing Zonesの心臓部である**管理グループ階層**と**ポリシーアーキテクチャ**を解説します。

実際のコードを見ながら、管理グループの階層構造、設定ファイル、そしてポリシーの適用方法を完全に理解していきましょう。

---

## Part 1: 管理グループの階層構造

### 管理グループとは何か？

管理グループは、複数のサブスクリプションをまとめて、ポリシーやRBACを一元管理する仕組みです。

いちばんわかりやすい例えをするなら、「フォルダ構造」です。

```
Tenant Root（テナントルート）
└── alz（Azure Landing Zones）
    ├── platform（共通基盤）
    │   ├── management（管理）
    │   ├── connectivity（接続）
    │   └── identity（ID管理）
    └── landingzones（アプリ環境）
        ├── corp（企業向け）
        └── online（オンライン向け）
```

### ポリシーの継承構造

管理グループの最大の特徴は、**親から子へのポリシー継承**です。

**例：全環境で同じルールを適用したい場合**

```
alz に「特定リージョン以外は使用禁止」ポリシーを適用
↓
配下の全管理グループ・サブスクリプションに自動適用
```

これにより、一度設定すれば全環境に適用されるので、管理の手間が激減します。

!!! tip "ポリシー継承の使い分け"
    - **alz**: 全環境共通のルール（リージョン制限、タグ必須など）
    - **platform**: 共通基盤のルール（ネットワーク設定、ログ転送など）
    - **landingzones**: アプリ環境のルール（VM診断設定、バックアップなど）

### この Chapter で学ぶこと

1. **設定ファイル（platform-landing-zone.auto.tfvars）**: どんな設定ができるのか（533行全解説）
2. **main.management.tf**: どうやって管理グループを作るのか
3. **lib/ フォルダ**: YAMLでポリシーをどう定義するのか
4. **locals.tf**: 設定がどう変換されるのか
5. **modules/management_groups/**: ローカルモジュールの役割
6. **公式モジュール**: Azure公式モジュールの内部構造
7. **実践パターン**: よくあるカスタマイズ方法

---

## Part 2: platform-landing-zone.auto.tfvarsの完全解説

このファイルで管理グループのすべてを設定します。ここでは管理グループに関連する部分だけを解説します。

### 管理グループとポリシー設定

これがこのChapterのメイン設定です。

```hcl title="management_group_settings"
management_group_settings = {
  enabled            = true
  architecture_name  = "alz_custom"
  location           = "$${starter_location_01}"
  parent_resource_id = "$${root_parent_management_group_id}"
  
  policy_default_values = {
    ama_change_tracking_data_collection_rule_id = "$${ama_change_tracking_data_collection_rule_id}"
    ama_mdfc_sql_data_collection_rule_id        = "$${ama_mdfc_sql_data_collection_rule_id}"
    ama_vm_insights_data_collection_rule_id     = "$${ama_vm_insights_data_collection_rule_id}"
    ama_user_assigned_managed_identity_id       = "$${ama_user_assigned_managed_identity_id}"
    ama_user_assigned_managed_identity_name     = "$${ama_user_assigned_managed_identity_name}"
    log_analytics_workspace_id                  = "$${log_analytics_workspace_id}"
    ddos_protection_plan_id                     = "$${ddos_protection_plan_id}"
    private_dns_zone_subscription_id            = "$${subscription_id_connectivity}"
    private_dns_zone_region                     = "$${starter_location_01}"
    private_dns_zone_resource_group_name        = "$${dns_resource_group_name}"
  }
  
  subscription_placement = {
    identity = {
      subscription_id       = "$${subscription_id_identity}"
      management_group_name = "identity"
    }
    connectivity = {
      subscription_id       = "$${subscription_id_connectivity}"
      management_group_name = "connectivity"
    }
    management = {
      subscription_id       = "$${subscription_id_management}"
      management_group_name = "management"
    }
    security = {
      subscription_id       = "$${subscription_id_security}"
      management_group_name = "security"
    }
  }
  
  policy_assignments_to_modify = {
    alz = {
      policy_assignments = {
        Deploy-MDFC-Config-H224 = {
          parameters = {
            ascExportResourceGroupName                  = "$${asc_export_resource_group_name}"
            ascExportResourceGroupLocation              = "$${starter_location_01}"
            emailSecurityContact                        = "$${defender_email_security_contact}"
            enableAscForServers                         = "DeployIfNotExists"
            enableAscForServersVulnerabilityAssessments = "DeployIfNotExists"
            enableAscForSql                             = "DeployIfNotExists"
            enableAscForAppServices                     = "DeployIfNotExists"
            enableAscForStorage                         = "DeployIfNotExists"
            enableAscForContainers                      = "DeployIfNotExists"
            enableAscForKeyVault                        = "DeployIfNotExists"
            enableAscForSqlOnVm                         = "DeployIfNotExists"
            enableAscForArm                             = "DeployIfNotExists"
            enableAscForOssDb                           = "DeployIfNotExists"
            enableAscForCosmosDbs                       = "DeployIfNotExists"
            enableAscForCspm                            = "DeployIfNotExists"
          }
        }
      }
    }
  }
}
```

**主要なパラメータ**:

#### `architecture_name`

```hcl
architecture_name = "alz_custom"
```

lib/architecture_definitions/ フォルダ内のYAMLファイル名を指定します。

→ `alz_custom.alz_architecture_definition.yaml` を読み込む

#### `parent_resource_id`

```hcl
parent_resource_id = "$${root_parent_management_group_id}"
```

ルート管理グループのIDです。通常はテナントルートまたは既存の親管理グループを指定します。

#### `policy_default_values`

ポリシーパラメータのデフォルト値です。ポリシーに定義されたパラメータを上書きできます。

**重要なポリシーパラメータ**:

| パラメータ | 用途 |
|----------|------|
| `ama_*_data_collection_rule_id` | Azure Monitor Agentのデータ収集ルールID |
| `ama_user_assigned_managed_identity_id` | AMA用マネージドIDのリソースID |
| `log_analytics_workspace_id` | Log AnalyticsワークスペースのリソースID |
| `ddos_protection_plan_id` | DDoS Protection PlanのリソースID |
| `private_dns_zone_*` | Private DNSゾーンの設定 |

これらの値は、ポリシーが作成するリソース（VM、SQL Serverなど）に自動的に適用されます。

#### `subscription_placement`

サブスクリプションを管理グループに配置する設定です。

```hcl
subscription_placement = {
  identity = {
    subscription_id       = "$${subscription_id_identity}"
    management_group_name = "identity"
  }
}
```

この設定により、指定したサブスクリプションが対応する管理グループに自動的に配置されます。

#### `policy_assignments_to_modify`

既存のポリシー割り当てを変更する設定です。

```hcl
policy_assignments_to_modify = {
  alz = {
    policy_assignments = {
      Deploy-MDFC-Config-H224 = {
        parameters = {
          emailSecurityContact = "$${defender_email_security_contact}"
          # ...
        }
      }
    }
  }
}
```

**使いどころ**:

- ポリシーパラメータの変更
- enforcement_modeの変更（強制モード/監査モード）
- マネージドIDの追加

### セクション6: 接続設定（行294-533）

Hub-and-SpokeやVirtual WANの設定です。詳細はChapter 10-11で解説します。

---

## Part 3: main.management.tfの解説

設定ファイルを読み込んで、実際に管理グループを作成するファイルです。

### ファイル全体

```hcl title="main.management.tf"
module "management_resources" {
  source = "./modules/management_resources"

  count = var.management_resources_enabled ? 1 : 0

  enable_telemetry             = var.enable_telemetry
  management_resource_settings = local.management_resource_settings

  providers = {
    azurerm = azurerm.management
  }
}

module "management_groups" {
  source = "./modules/management_groups"

  count = var.management_groups_enabled ? 1 : 0

  enable_telemetry          = var.enable_telemetry
  management_group_settings = local.management_group_settings
}

moved {
  from = module.management_groups
  to   = module.management_groups[0]
}

moved {
  from = module.management_resources
  to   = module.management_resources[0]
}
```

### countパターンによる条件付き作成

```hcl
count = var.management_resources_enabled ? 1 : 0
```

このパターンにより、変数で有効/無効を切り替えられます。

**動作**:

- `var.management_resources_enabled = true` → `count = 1` → モジュールを1つ作成
- `var.management_resources_enabled = false` → `count = 0` → モジュールを作成しない

### movedブロックによる状態移行

```hcl
moved {
  from = module.management_groups
  to   = module.management_groups[0]
}
```

**このブロックの役割**:

以前のバージョンでは `module.management_groups` という名前で状態管理していました。

countパターン導入後は `module.management_groups[0]` という名前になります。

movedブロックがないと、Terraformは「古いリソースを削除して新しいリソースを作成」しようとしますが、movedブロックがあることで「名前を変更するだけ」で済みます。

!!! tip "movedブロックのベストプラクティス"
    - 既存環境を壊さずにコード構造を変更できる
    - terraform plan で `moved` と表示される
    - 一度適用した後も残しておくことで、古い環境からの移行をサポート

### 使用しているローカル変数

```hcl
management_resource_settings = local.management_resource_settings
management_group_settings    = local.management_group_settings
```

これらの変数は `locals.tf` で定義されています（Part 5で解説）。

---

## Part 4: lib/フォルダの解説

YAMLファイルで管理グループの階層構造とポリシーを定義します。

### フォルダ構造

```
lib/
├── alz_library_metadata.json
├── architecture_definitions/
│   └── alz_custom.alz_architecture_definition.yaml
└── archetype_definitions/
    ├── root_custom.alz_archetype_override.yaml
    ├── platform_custom.alz_archetype_override.yaml
    ├── management_custom.alz_archetype_override.yaml
    ├── connectivity_custom.alz_archetype_override.yaml
    ├── identity_custom.alz_archetype_override.yaml
    ├── landing_zones_custom.alz_archetype_override.yaml
    ├── corp_custom.alz_archetype_override.yaml
    ├── online_custom.alz_archetype_override.yaml
    ├── sandbox_custom.alz_archetype_override.yaml
    ├── security_custom.alz_archetype_override.yaml
    └── decommissioned_custom.alz_archetype_override.yaml
```

### architecture_definitions: 管理グループ階層の定義

```yaml title="lib/architecture_definitions/alz_custom.alz_architecture_definition.yaml"
name: alz_custom
management_groups:
  - id: alz
    display_name: Azure Landing Zones
    archetypes:
      - root_custom
    exists: false
    parent_id: null

  - id: platform
    display_name: Platform
    archetypes:
      - platform_custom
    exists: false
    parent_id: alz

  - id: landingzones
    display_name: Landing Zones
    archetypes:
      - landing_zones_custom
    exists: false
    parent_id: alz

  - id: corp
    display_name: Corp
    archetypes:
      - corp_custom
    exists: false
    parent_id: landingzones

  - id: online
    display_name: Online
    archetypes:
      - online_custom
    exists: false
    parent_id: landingzones

  - id: sandbox
    display_name: Sandbox
    archetypes:
      - sandbox_custom
    exists: false
    parent_id: alz

  - id: security
    display_name: Security
    archetypes:
      - security_custom
    exists: false
    parent_id: platform

  - id: management
    display_name: Management
    archetypes:
      - management_custom
    exists: false
    parent_id: platform

  - id: connectivity
    display_name: Connectivity
    archetypes:
      - connectivity_custom
    exists: false
    parent_id: platform

  - id: identity
    display_name: Identity
    archetypes:
      - identity_custom
    exists: false
    parent_id: platform

  - id: decommissioned
    display_name: Decommissioned
    archetypes:
      - decommissioned_custom
    exists: false
    parent_id: alz
```

**各フィールドの意味**:

- `id`: 管理グループの一意な識別子
- `display_name`: Azureポータルで表示される名前
- `archetypes`: この管理グループに適用するアーキタイプ（ポリシーセット）
- `exists`: 既存の管理グループか（falseの場合は新規作成）
- `parent_id`: 親管理グループのID

### archetype_definitions: ポリシーのカスタマイズ

各管理グループごとにポリシーをカスタマイズできます。

```yaml title="lib/archetype_definitions/root_custom.alz_archetype_override.yaml"
base_archetype: root
name: root_custom
policy_assignments_to_add: []
policy_assignments_to_remove: []
policy_definitions_to_add: []
policy_definitions_to_remove: []
policy_set_definitions_to_add: []
policy_set_definitions_to_remove: []
role_definitions_to_add: []
role_definitions_to_remove: []
```

**各フィールドの意味**:

- `base_archetype`: ベースとなるアーキタイプ（公式のALZアーキタイプ）
- `name`: カスタムアーキタイプの名前
- `policy_assignments_to_add`: 追加するポリシー割り当て
- `policy_assignments_to_remove`: 削除するポリシー割り当て
- `policy_definitions_to_add`: 追加するカスタムポリシー定義
- `policy_definitions_to_remove`: 削除するポリシー定義
- `policy_set_definitions_to_add`: 追加するポリシーイニシアチブ
- `policy_set_definitions_to_remove`: 削除するポリシーイニシアチブ
- `role_definitions_to_add`: 追加するカスタムロール定義
- `role_definitions_to_remove`: 削除するロール定義

**実際のカスタマイズ例**:

```yaml title="lib/archetype_definitions/connectivity_custom.alz_archetype_override.yaml"
base_archetype: connectivity
name: connectivity_custom
policy_assignments_to_add: []
policy_assignments_to_remove:
  # DDoS Protection Planが未作成の場合は削除
  # - Enable-DDoS-VNET
policy_definitions_to_add: []
policy_definitions_to_remove: []
policy_set_definitions_to_add: []
policy_set_definitions_to_remove: []
role_definitions_to_add: []
role_definitions_to_remove: []
```

!!! tip "ポリシーのカスタマイズ方法"
    - コメントアウトを外して有効化: `# - Enable-DDoS-VNET` → `- Enable-DDoS-VNET`
    - カスタムポリシーを追加: `policy_definitions_to_add` に定義を追加
    - 不要なポリシーを削除: `policy_assignments_to_remove` にポリシー名を追加

---

## Part 5: locals.tfの変換処理

platform-landing-zone.auto.tfvars の設定を、モジュールに渡す形式に変換する処理です。

### ファイル全体

```hcl title="locals.tf"
locals {
  const = {
    connectivity = {
      virtual_wan        = "virtual_wan"
      hub_and_spoke_vnet = "hub_and_spoke_vnet"
      none               = "none"
    }
  }
}

locals {
  connectivity_enabled                    = var.connectivity_type != local.const.connectivity.none
  connectivity_virtual_wan_enabled        = var.connectivity_type == local.const.connectivity.virtual_wan
  connectivity_hub_and_spoke_vnet_enabled = var.connectivity_type == local.const.connectivity.hub_and_spoke_vnet
}

# Build an implicit dependency on the resource groups
locals {
  resource_groups = {
    resource_groups = module.resource_groups
  }
  hub_and_spoke_networks_settings = merge(module.config.outputs.hub_and_spoke_networks_settings, local.resource_groups)
  hub_virtual_networks            = (merge({ vnets = module.config.outputs.hub_virtual_networks }, local.resource_groups)).vnets
  virtual_wan_settings            = merge(module.config.outputs.virtual_wan_settings, local.resource_groups)
  virtual_hubs                    = (merge({ vhubs = module.config.outputs.virtual_hubs }, local.resource_groups)).vhubs
}

# Build policy dependencies
locals {
  management_group_dependencies = {
    policy_assignments = [
      module.management_resources,
      module.hub_and_spoke_vnet,
      module.virtual_wan
    ]
    policy_role_assignments = [
      module.management_resources,
      module.hub_and_spoke_vnet,
      module.virtual_wan
    ]
  }
}

locals {
  management_group_settings = merge(
    module.config.outputs.management_group_settings,
    {
      dependencies = local.management_group_dependencies
    }
  )
  management_resource_settings = merge(
    module.config.outputs.management_resource_settings,
    {
      tags = coalesce(module.config.outputs.management_resource_settings.tags, module.config.outputs.tags)
    }
  )
}
```

### 処理の流れ

#### 1. 定数定義

```hcl
locals {
  const = {
    connectivity = {
      virtual_wan        = "virtual_wan"
      hub_and_spoke_vnet = "hub_and_spoke_vnet"
      none               = "none"
    }
  }
}
```

接続タイプの定数を定義しています。マジックストリングを避けるためのベストプラクティスです。

#### 2. 接続タイプの判定

```hcl
locals {
  connectivity_enabled                    = var.connectivity_type != local.const.connectivity.none
  connectivity_virtual_wan_enabled        = var.connectivity_type == local.const.connectivity.virtual_wan
  connectivity_hub_and_spoke_vnet_enabled = var.connectivity_type == local.const.connectivity.hub_and_spoke_vnet
}
```

接続タイプに応じた条件変数を作成しています。

#### 3. リソースグループの依存関係

```hcl
locals {
  resource_groups = {
    resource_groups = module.resource_groups
  }
  hub_and_spoke_networks_settings = merge(module.config.outputs.hub_and_spoke_networks_settings, local.resource_groups)
}
```

接続リソースがリソースグループに依存することを明示的に定義しています。

#### 4. ポリシーの依存関係（重要！）

```hcl
locals {
  management_group_dependencies = {
    policy_assignments = [
      module.management_resources,
      module.hub_and_spoke_vnet,
      module.virtual_wan
    ]
    policy_role_assignments = [
      module.management_resources,
      module.hub_and_spoke_vnet,
      module.virtual_wan
    ]
  }
}
```

**なぜ依存関係が必要か？**

ポリシーは、Log AnalyticsワークスペースやDDoS Protection Planなどのリソースを参照します。

しかし、Terraformは自動的にこの依存関係を検出できません（ポリシーパラメータは文字列として渡されるため）。

そのため、明示的に依存関係を定義しています。

**実際の動作**:

1. `module.management_resources` が作成される（Log Analyticsなど）
2. `module.hub_and_spoke_vnet` が作成される（DDoS Planなど）
3. その後、`module.management_groups` が作成される（ポリシー割り当て）

#### 5. 設定のマージ

```hcl
locals {
  management_group_settings = merge(
    module.config.outputs.management_group_settings,
    {
      dependencies = local.management_group_dependencies
    }
  )
}
```

config-templatingモジュールの出力に、依存関係を追加しています。

**処理の流れ**:

1. `platform-landing-zone.auto.tfvars` の `management_group_settings` を読み込む
2. config-templatingモジュールで変数置換を実行
3. `local.management_group_dependencies` を追加
4. 最終的な設定を `local.management_group_settings` に格納

---

## Part 6: modules/management_groups/の解説

ローカルモジュールで、設定を公式モジュールに渡す前処理を行います。

### モジュール構造

```
modules/management_groups/
├── main.tf          # 公式モジュール呼び出し
├── variables.tf     # 入力変数定義
├── locals.tf        # データ変換処理
└── terraform.tf     # Terraform設定
```

### main.tf: 公式モジュール呼び出し

```hcl title="modules/management_groups/main.tf"
module "management_groups" {
  source                                                        = "Azure/avm-ptn-alz/azurerm"
  version                                                       = "0.14.1"
  architecture_name                                             = var.management_group_settings.architecture_name
  parent_resource_id                                            = var.management_group_settings.parent_resource_id
  location                                                      = var.management_group_settings.location
  policy_default_values                                         = local.policy_default_values
  policy_assignments_to_modify                                  = local.policy_assignments_to_modify
  enable_telemetry                                              = var.enable_telemetry
  management_group_hierarchy_settings                           = var.management_group_settings.management_group_hierarchy_settings
  partner_id                                                    = var.management_group_settings.partner_id
  retries                                                       = var.management_group_settings.retries
  subscription_placement                                        = var.management_group_settings.subscription_placement
  timeouts                                                      = var.management_group_settings.timeouts
  dependencies                                                  = var.management_group_settings.dependencies
  override_policy_definition_parameter_assign_permissions_set   = var.management_group_settings.override_policy_definition_parameter_assign_permissions_set
  override_policy_definition_parameter_assign_permissions_unset = var.management_group_settings.override_policy_definition_parameter_assign_permissions_unset
  management_group_role_assignments                             = var.management_group_settings.management_group_role_assignments
  role_assignment_definition_lookup_enabled                     = var.management_group_settings.role_assignment_definition_lookup_enabled
  policy_assignment_non_compliance_message_settings             = var.management_group_settings.policy_assignment_non_compliance_message_settings
  role_assignment_name_use_random_uuid                          = var.management_group_settings.role_assignment_name_use_random_uuid
}
```

**主要なパラメータ**:

| パラメータ | 説明 |
|----------|------|
| `architecture_name` | アーキテクチャ定義ファイル名（例: `alz_custom`） |
| `parent_resource_id` | 親管理グループのリソースID |
| `location` | デフォルトリージョン |
| `policy_default_values` | ポリシーパラメータのデフォルト値 |
| `policy_assignments_to_modify` | ポリシー割り当ての変更 |
| `subscription_placement` | サブスクリプションの配置 |
| `dependencies` | 依存関係の定義 |

### locals.tf: データ変換処理

```hcl title="modules/management_groups/locals.tf"
locals {
  policy_default_values = { for k, v in try(var.management_group_settings.policy_default_values, {}) : k => jsonencode({ value = v }) }
  policy_assignments_to_modify = { for management_group_key, management_group_value in try(var.management_group_settings.policy_assignments_to_modify, {}) : management_group_key => {
    policy_assignments = { for policy_assignment_key, policy_assignment_value in try(management_group_value.policy_assignments, {}) : policy_assignment_key => {
      enforcement_mode        = try(policy_assignment_value.enforcement_mode, null)
      identity                = try(policy_assignment_value.identity, null)
      identity_ids            = try(policy_assignment_value.identity_ids, null)
      parameters              = try({ for parameter_key, parameter_value in try(policy_assignment_value.parameters, {}) : parameter_key => jsonencode({ value = parameter_value }) }, null)
      non_compliance_messages = try(policy_assignment_value.non_compliance_messages, null)
      resource_selectors      = try(policy_assignment_value.resource_selectors, null)
      overrides               = try(policy_assignment_value.overrides, null)
    } }
  } }
}
```

**この変換の目的**:

Azure Policyは、パラメータをJSON形式で受け取る必要があります。

**変換前（platform-landing-zone.auto.tfvars）**:

```hcl
policy_default_values = {
  log_analytics_workspace_id = "/subscriptions/.../workspaces/law-001"
}
```

**変換後（公式モジュールに渡す形式）**:

```json
{
  "log_analytics_workspace_id": "{\"value\":\"/subscriptions/.../workspaces/law-001\"}"
}
```

---

## Part 7: 公式モジュールの内部解説

**公式モジュール**: `Azure/avm-ptn-alz/azurerm` v0.14.1

https://github.com/Azure/terraform-azurerm-avm-ptn-alz

このモジュールがどうやって管理グループとポリシーを作成しているのか、実際のコードを見ながら完全に理解していきましょう。

### モジュールのファイル構成

```
Azure/terraform-azurerm-avm-ptn-alz/
├── main.tf                           # ALZ Providerからデータ取得
├── locals.tf                         # データ変換処理
├── main.management_groups.tf         # 管理グループ作成（レベル0-6）
├── main.policy_definitions.tf        # ポリシー定義作成
├── main.policy_set_definitions.tf    # ポリシーセット定義作成
├── main.policy_assignments.tf        # ポリシー割り当て作成
├── main.policy_role_assignments.tf   # ポリシーロール割り当て作成
├── main.role_definitions.tf          # カスタムロール定義作成
├── main.role_assignments.tf          # 管理グループロール割り当て作成
├── variables.tf                      # 入力変数定義
└── outputs.tf                        # 出力値定義
```

### ステップ1: データソースによるアーキテクチャ読み込み

まず最初に、YAMLファイルを読み込んで処理します。

```hcl title="main.tf"
data "alz_architecture" "this" {
  name                         = var.architecture_name
  root_management_group_id     = var.parent_resource_id
  location                     = var.location
  policy_assignments_to_modify = var.policy_assignments_to_modify
  policy_default_values        = var.policy_default_values

  override_policy_definition_parameter_assign_permissions_set   = var.override_policy_definition_parameter_assign_permissions_set
  override_policy_definition_parameter_assign_permissions_unset = var.override_policy_definition_parameter_assign_permissions_unset
}
```

**このデータソースが何をしているか**:

1. **YAMLファイルの読み込み**
   - `lib/architecture_definitions/alz_custom.alz_architecture_definition.yaml` を読み込む
   - `lib/archetype_definitions/*.yaml` を読み込む

2. **Azure ALZ Libraryの読み込み**
   - 公式のALZポリシー定義を読み込む
   - アーキタイプごとのポリシー割り当てを読み込む

3. **データの統合**
   - カスタム定義と公式定義をマージ
   - `policy_assignments_to_modify` でポリシーパラメータを上書き
   - `policy_default_values` でデフォルト値を設定

**ALZ Provider**とは？

このモジュールは、Terraformの `alz` プロバイダーを使用しています。

```hcl
provider "alz" {
  library_references = [
    {
      path = "platform/alz",
      ref  = "2025.09.0"
    },
    {
      custom_url = "${path.root}/lib"
    }
  ]
}
```

- **path**: GitHub上の公式ALZライブラリ（https://github.com/Azure/Azure-Landing-Zones-Library）
- **ref**: ライブラリのバージョンタグ
- **custom_url**: ローカルのカスタムライブラリ

### ステップ2: データ変換（locals.tf）

データソースから取得した生データを、Terraformリソースで使える形式に変換します。

#### 管理グループの変換

```hcl title="locals.tf（管理グループ）"
locals {
  management_groups = { for v in data.alz_architecture.this.management_groups : v.id => {
    id           = v.id
    level        = v.level
    exists       = v.exists
    display_name = v.display_name
    parent_id    = v.parent_id
  } }
  management_groups_level_0 = { for k, v in local.management_groups : k => v if v.level == 0 && !v.exists }
  management_groups_level_1 = { for k, v in local.management_groups : k => v if v.level == 1 && !v.exists }
  management_groups_level_2 = { for k, v in local.management_groups : k => v if v.level == 2 && !v.exists }
  management_groups_level_3 = { for k, v in local.management_groups : k => v if v.level == 3 && !v.exists }
  management_groups_level_4 = { for k, v in local.management_groups : k => v if v.level == 4 && !v.exists }
  management_groups_level_5 = { for k, v in local.management_groups : k => v if v.level == 5 && !v.exists }
  management_groups_level_6 = { for k, v in local.management_groups : k => v if v.level == 6 && !v.exists }
}
```

**なぜレベル別に分けるのか？**

管理グループには親子関係があるので、親を先に作成する必要があります。

```
Level 0: alz（ルート）
  ├─ Level 1: platform, landingzones, sandbox
  │   ├─ Level 2: management, connectivity, identity
  │   └─ Level 2: corp, online
```

依存関係の例：
- Level 0を作成 → Level 1を作成 → Level 2を作成...

#### ポリシー定義の変換

```hcl title="locals.tf（ポリシー定義）"
locals {
  policy_definitions = {
    for pdval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for pdname, pd in mg.policy_definitions : {
          key        = pdname
          definition = jsondecode(pd)
          mg         = mg.id
        }
      ]
  ]) : "${pdval.mg}/${pdval.key}" => pdval }
}
```

**この処理が何をしているか**:

1. **入れ子ループで展開**
   - 各管理グループ (`mg`) をループ
   - 各管理グループ内のポリシー定義 (`pdname`, `pd`) をループ

2. **JSON文字列をオブジェクトに変換**
   - `jsondecode(pd)`: JSON文字列をTerraformオブジェクトに変換

3. **キーを生成**
   - `"${pdval.mg}/${pdval.key}"`: 例: `"alz/Deny-Classic-Resources"`
   - 管理グループID + ポリシー定義名で一意のキーを作成

**例：実際のデータ構造**

```
{
  "alz/Deny-Classic-Resources" = {
    key = "Deny-Classic-Resources"
    definition = {
      name = "Deny-Classic-Resources"
      properties = {
        displayName = "Deny the deployment of classic resources"
        policyType = "Custom"
        mode = "All"
        ...
      }
    }
    mg = "alz"
  }
}
```

#### ポリシーセット定義の変換

```hcl title="locals.tf（ポリシーセット定義）"
locals {
  policy_set_definitions = {
    for psdval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for psdname, psd in mg.policy_set_definitions : {
          key            = psdname
          set_definition = jsondecode(psd)
          mg             = mg.id
        }
      ]
  ]) : "${psdval.mg}/${psdval.key}" => psdval }
}
```

ポリシーセット定義（Policy Initiative）は、複数のポリシー定義をまとめたものです。

**例：Enforce-Encryption-CMK**

このポリシーセットは、複数のリソースタイプで顧客管理キー（CMK）暗号化を強制するポリシーをまとめています。

#### ポリシー割り当ての変換

```hcl title="locals.tf（ポリシー割り当て）"
locals {
  policy_assignments = {
    for paval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for paname, pa in mg.policy_assignments : {
          key        = paname
          assignment = jsondecode(pa)
          mg         = mg.id
        }
      ]
  ]) : "${paval.mg}/${paval.key}" => paval }
  
  policy_assignments_final = {
    for k, v in local.policy_assignments : k => {
      mg         = v.mg
      assignment = merge(v.assignment, local.policy_assignments_properties_final[k])
    }
  }
  
  policy_assignments_properties_final = {
    for k, v in local.policy_assignments : k => {
      properties = merge(v.assignment.properties, local.policy_assignment_non_compliance_messages[k])
    }
  }
}
```

**この処理の流れ**:

1. `policy_assignments`: 基本的な変換
2. `policy_assignments_final`: non-compliance messagesを追加
3. `policy_assignments_properties_final`: propertiesをマージ

### ステップ3: 管理グループの作成

レベルごとに順番に作成していきます。

```hcl title="main.management_groups.tf（Level 0）"
resource "azapi_resource" "management_groups_level_0" {
  for_each = local.management_groups_level_0

  name      = each.value.id
  parent_id = "/"
  type      = "Microsoft.Management/managementGroups@2023-04-01"
  body = {
    properties = {
      details = {
        parent = {
          id = "/providers/Microsoft.Management/managementGroups/${each.value.parent_id}"
        }
      }
      displayName = each.value.display_name
    }
  }
  create_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers   = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  
  replace_triggers_external_values = [
    each.value.parent_id,
  ]
  response_export_values = []
  
  retry = var.retries.management_groups.error_message_regex != null ? {
    error_message_regex  = var.retries.management_groups.error_message_regex
    interval_seconds     = lookup(var.retries.management_groups, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.management_groups, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.management_groups, "multiplier", null)
    randomization_factor = lookup(var.retries.management_groups, "randomization_factor", null)
  } : null
  
  schema_validation_enabled = var.schema_validation_enabled.management_groups
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.management_group.create
    delete = var.timeouts.management_group.delete
    read   = var.timeouts.management_group.read
    update = var.timeouts.management_group.update
  }

  depends_on = [terraform_data.management_groups_dependencies]
}
```

**重要なポイント**:

1. **azapi_resourceの使用**
   - AzureRMプロバイダーではなく、AzAPIプロバイダーを使用
   - より柔軟で、リトライ機能が組み込まれている

2. **retry設定**
   - Azure APIは一時的なエラーを返すことがある
   - 自動リトライで対処

3. **replace_triggers_external_values**
   - `parent_id`が変更されたら、管理グループを再作成
   - 親子関係の変更を検出

4. **depends_on**
   - Level 0 → Level 1 → Level 2の順に作成
   - `depends_on = [azapi_resource.management_groups_level_0]`

**Level 1-6も同様の構造**:

```hcl
resource "azapi_resource" "management_groups_level_1" {
  for_each = local.management_groups_level_1
  # ... 同じ構造 ...
  depends_on = [azapi_resource.management_groups_level_0]
}

resource "azapi_resource" "management_groups_level_2" {
  for_each = local.management_groups_level_2
  # ... 同じ構造 ...
  depends_on = [azapi_resource.management_groups_level_1]
}

# Level 3, 4, 5, 6も同様...
```

### ステップ4: ポリシー定義の作成

```hcl title="main.policy_definitions.tf"
resource "azapi_resource" "policy_definitions" {
  for_each = local.policy_definitions

  name      = each.value.definition.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_definitions, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policyDefinitions@2023-04-01"
  body = {
    properties = each.value.definition.properties
  }
  
  create_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers           = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  response_export_values = []
  
  retry = var.retries.policy_definitions.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_definitions.error_message_regex
    interval_seconds     = lookup(var.retries.policy_definitions, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_definitions, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_definitions, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_definitions, "randomization_factor", null)
  } : null
  
  schema_validation_enabled = var.schema_validation_enabled.policy_definitions
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_definition.create
    delete = var.timeouts.policy_definition.delete
    read   = var.timeouts.policy_definition.read
    update = var.timeouts.policy_definition.update
  }

  depends_on = [
    time_sleep.after_management_groups,
  ]
}
```

**重要なポイント**:

1. **parent_id の構築**
   ```hcl
   parent_id = "/providers/Microsoft.Management/managementGroups/${each.value.mg}"
   ```
   - ポリシー定義は管理グループに紐づく
   - 例: `/providers/Microsoft.Management/managementGroups/alz`

2. **depends_on で管理グループ作成を待つ**
   ```hcl
   depends_on = [time_sleep.after_management_groups]
   ```
   - 管理グループが作成されてから、ポリシー定義を作成

3. **リトライ機能**
   - ポリシー定義の作成は失敗することがある（結果整合性）
   - 自動リトライで対処

### ステップ5: ポリシーセット定義の作成

```hcl title="main.policy_set_definitions.tf"
resource "azapi_resource" "policy_set_definitions" {
  for_each = local.policy_set_definitions

  name      = each.value.set_definition.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_set_definitions, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policySetDefinitions@2023-04-01"
  body = {
    properties = each.value.set_definition.properties
  }
  
  create_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers           = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  response_export_values = []
  
  retry = var.retries.policy_set_definitions.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_set_definitions.error_message_regex
    interval_seconds     = lookup(var.retries.policy_set_definitions, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_set_definitions, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_set_definitions, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_set_definitions, "randomization_factor", null)
  } : null
  
  schema_validation_enabled = var.schema_validation_enabled.policy_set_definitions
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_set_definition.create
    delete = var.timeouts.policy_set_definition.delete
    read   = var.timeouts.policy_set_definition.read
    update = var.timeouts.policy_set_definition.update
  }

  depends_on = [
    time_sleep.after_policy_definitions,
  ]
}
```

**ポリシーセット定義の構造**:

```json
{
  "properties": {
    "displayName": "Enforce encryption at rest with CMK",
    "policyDefinitions": [
      {
        "policyDefinitionId": "/providers/Microsoft.Management/managementGroups/alz/providers/Microsoft.Authorization/policyDefinitions/Deny-Storage-Without-Encryption",
        "parameters": {}
      },
      {
        "policyDefinitionId": "/providers/Microsoft.Management/managementGroups/alz/providers/Microsoft.Authorization/policyDefinitions/Deny-Sql-Without-Encryption",
        "parameters": {}
      }
    ]
  }
}
```

### ステップ6: ポリシー割り当ての作成

```hcl title="main.policy_assignments.tf"
resource "terraform_data" "policy_assignments_dependencies" {
  input = sha256(jsonencode(var.dependencies.policy_assignments))
}

resource "azapi_resource" "policy_assignments" {
  for_each = local.policy_assignments_final

  location  = var.location
  name      = each.value.assignment.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_assignments, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policyAssignments@2024-04-01"
  body = {
    properties = {
      description       = lookup(each.value.assignment.properties, "description", null)
      definitionVersion = lookup(each.value.assignment.properties, "definitionVersion", "1.*.*")
      displayName       = lookup(each.value.assignment.properties, "displayName", null)
      enforcementMode   = lookup(each.value.assignment.properties, "enforcementMode", null)
      metadata = merge(lookup(each.value.assignment.properties, "metadata", {}),
        {
          createdBy = ""
          createdOn = ""
          updatedBy = ""
          updatedOn = ""
        }
      )
      nonComplianceMessages = lookup(each.value.assignment.properties, "nonComplianceMessages", null)
      notScopes             = lookup(each.value.assignment.properties, "notScopes", null)
      overrides             = lookup(each.value.assignment.properties, "overrides", null)
      parameters            = lookup(each.value.assignment.properties, "parameters", null)
      policyDefinitionId    = lookup(each.value.assignment.properties, "policyDefinitionId", null)
      resourceSelectors     = lookup(each.value.assignment.properties, "resourceSelectors", null)
    }
  }
  
  create_headers          = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers          = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  ignore_missing_property = true
  read_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  
  replace_triggers_external_values = [
    lookup(each.value.assignment.properties, "policyDefinitionId", null),
    var.location,
  ]
  response_export_values = []
  
  retry = var.retries.policy_assignments.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_assignments.error_message_regex
    interval_seconds     = lookup(var.retries.policy_assignments, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_assignments, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_assignments, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_assignments, "randomization_factor", null)
  } : null
  
  schema_validation_enabled = var.schema_validation_enabled.policy_assignments
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  dynamic "identity" {
    for_each = lookup(each.value.assignment, "identity", null) != null ? [each.value.assignment.identity] : []

    content {
      type         = identity.value.type
      identity_ids = keys(lookup(identity.value, "userAssignedIdentities", {}))
    }
  }
  
  timeouts {
    create = var.timeouts.policy_assignment.create
    delete = var.timeouts.policy_assignment.delete
    read   = var.timeouts.policy_assignment.read
    update = var.timeouts.policy_assignment.update
  }

  depends_on = [
    time_sleep.after_policy_set_definitions,
    terraform_data.policy_assignments_dependencies,
  ]
}
```

**重要なポイント**:

1. **location の指定**
   - ポリシー割り当てにはlocationが必要（マネージドIDの作成先）

2. **identity ブロック**
   ```hcl
   dynamic "identity" {
     for_each = lookup(each.value.assignment, "identity", null) != null ? [each.value.assignment.identity] : []
     content {
       type         = identity.value.type
       identity_ids = keys(lookup(identity.value, "userAssignedIdentities", {}))
     }
   }
   ```
   - ポリシーがリソースを作成する場合、マネージドIDが必要
   - SystemAssigned または UserAssigned

3. **dependencies の明示的な指定**
   ```hcl
   depends_on = [
     time_sleep.after_policy_set_definitions,
     terraform_data.policy_assignments_dependencies,
   ]
   ```
   - `terraform_data.policy_assignments_dependencies`: 外部リソース（Log Analyticsなど）の作成を待つ
   - locals.tfで定義した `var.dependencies.policy_assignments`

### ステップ7: ポリシーロール割り当ての作成

ポリシーがリソースを作成する場合、そのマネージドIDに権限を付与する必要があります。

```hcl title="main.policy_role_assignments.tf"
resource "terraform_data" "policy_role_assignments_dependencies" {
  input = sha256(jsonencode(var.dependencies.policy_role_assignments))
}

data "azapi_resource" "policy_user_assigned_identities" {
  for_each = local.policy_assignments_user_assigned_identity

  resource_id = each.value[0]
  type        = "Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31"
  response_export_values = [
    "properties.principalId",
  ]

  depends_on = [
    terraform_data.policy_role_assignments_dependencies,
    terraform_data.policy_assignments_dependencies,
  ]
}

resource "azapi_resource" "policy_role_assignments" {
  for_each = local.policy_role_assignments

  name      = each.key
  parent_id = each.value.scope
  type      = "Microsoft.Authorization/roleAssignments@2022-04-01"
  body = {
    properties = {
      principalId      = each.value.principal_id
      roleDefinitionId = each.value.role_definition_id
      description      = "Created by ALZ Terraform provider. Assignment required for Azure Policy."
    }
  }
  
  create_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers           = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  response_export_values = []
  
  retry = var.retries.policy_role_assignments.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_role_assignments.error_message_regex
    interval_seconds     = lookup(var.retries.policy_role_assignments, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_role_assignments, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_role_assignments, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_role_assignments, "randomization_factor", null)
  } : null
  
  schema_validation_enabled = var.schema_validation_enabled.role_assignments
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_role_assignment.create
    delete = var.timeouts.policy_role_assignment.delete
    read   = var.timeouts.policy_role_assignment.read
    update = var.timeouts.policy_role_assignment.update
  }

  depends_on = [terraform_data.policy_role_assignments_dependencies]

  lifecycle {
    ignore_changes = [output.properties.updatedOn]
  }
}
```

**ロール割り当ての自動生成**:

公式モジュールは、ポリシー定義のメタデータを読み取って、必要なロール割り当てを自動的に作成します。

**例：ポリシー定義のメタデータ**

```json
{
  "name": "Deploy-Log-Analytics-Agent",
  "properties": {
    "parameters": {
      "logAnalytics": {
        "type": "String",
        "metadata": {
          "assignPermissions": true,
          "description": "Log Analytics workspace"
        }
      }
    },
    "policyRule": {
      "if": {
        "field": "type",
        "equals": "Microsoft.Compute/virtualMachines"
      },
      "then": {
        "effect": "deployIfNotExists",
        "details": {
          "type": "Microsoft.Compute/virtualMachines/extensions",
          "roleDefinitionIds": [
            "/providers/microsoft.authorization/roleDefinitions/92aaf0da-9dab-42b6-94a3-d43ce8d16293"
          ]
        }
      }
    }
  }
}
```

**assignPermissions が true の場合**:

- `roleDefinitionIds` に記載されたロールを自動的に付与
- スコープ: ポリシーパラメータで指定されたリソース（Log Analyticsワークスペースなど）

**locals.tfでのロール割り当て生成**:

```hcl
locals {
  policy_role_assignments = data.alz_architecture.this.policy_role_assignments != null ? {
    for pra in data.alz_architecture.this.policy_role_assignments : uuidv5("url", "${pra.policy_assignment_name}${pra.scope}${pra.management_group_id}${pra.role_definition_id}") => {
      principal_id       = lookup(local.policy_assignment_identities, "${pra.management_group_id}/${pra.policy_assignment_name}", tostring(null))
      role_definition_id = startswith(lower(pra.scope), "/subscriptions") ? "/subscriptions/${split("/", pra.scope)[2]}${pra.role_definition_id}" : pra.role_definition_id
      scope              = pra.scope
    } if !strcontains(pra.scope, "00000000-0000-0000-0000-000000000000")
  } : {}
}
```

### ステップ8: マネージドIDの principal_id 取得

```hcl
locals {
  policy_assignment_identities = {
    for k, v in azapi_resource.policy_assignments : k => contains(keys(data.azapi_resource.policy_user_assigned_identities), k) ? data.azapi_resource.policy_user_assigned_identities[k].output.properties.principalId : try(v.identity[0].principal_id, tostring(null))
  }
}
```

**この処理が何をしているか**:

1. **SystemAssigned の場合**
   - `azapi_resource.policy_assignments.identity[0].principal_id` から取得

2. **UserAssigned の場合**
   - `data.azapi_resource.policy_user_assigned_identities` から取得
   - 別途作成されたマネージドIDのprincipal_idを取得

### 処理の全体フロー

```
1. data.alz_architecture でYAML読み込み
   ↓
2. locals.tf でデータ変換
   ├─ management_groups をレベル別に分類
   ├─ policy_definitions をマップに変換
   ├─ policy_set_definitions をマップに変換
   ├─ policy_assignments をマップに変換
   └─ policy_role_assignments を生成
   ↓
3. 管理グループ作成（Level 0 → 6）
   ↓
4. ポリシー定義作成
   ↓
5. ポリシーセット定義作成
   ↓
6. ポリシー割り当て作成（マネージドID付き）
   ↓
7. ポリシーロール割り当て作成
```

### time_sleep リソースによる待機

```hcl
resource "time_sleep" "after_management_groups" {
  create_duration = "30s"

  depends_on = [
    azapi_resource.management_groups_level_0,
    azapi_resource.management_groups_level_1,
    azapi_resource.management_groups_level_2,
    azapi_resource.management_groups_level_3,
    azapi_resource.management_groups_level_4,
    azapi_resource.management_groups_level_5,
    azapi_resource.management_groups_level_6,
  ]

  triggers = {
    management_groups = sha256(jsonencode({
      for k, v in local.management_groups : k => v.id
    }))
  }
}
```

**なぜ待機が必要か？**

Azure APIは結果整合性モデルです。

- 管理グループを作成後、すぐにGETできないことがある
- 30秒待機することで、Azure内部での伝播を待つ

### 公式モジュールの設計思想

1. **冪等性の確保**
   - 何度実行しても同じ結果になる
   - リトライ機能で一時的なエラーを吸収

2. **依存関係の明示**
   - `depends_on` で順序を制御
   - `terraform_data` で外部依存関係を追跡

3. **柔軟なカスタマイズ**
   - `policy_assignments_to_modify` でポリシーパラメータを上書き
   - `policy_default_values` でデフォルト値を設定

4. **自動化**
   - ロール割り当ての自動生成
   - メタデータに基づく処理

---

## Part 8: 実践パターン

よくあるカスタマイズパターンを紹介します。

### パターン1: カスタムポリシーの追加

**シナリオ**: 特定のリージョンのみ許可するポリシーを追加したい

#### ステップ1: ポリシー定義を作成

```json title="lib/policy_definitions/allowed_locations.json"
{
  "name": "Allowed-Locations",
  "properties": {
    "displayName": "Allowed locations",
    "policyType": "Custom",
    "mode": "All",
    "description": "This policy enables you to restrict the locations your organization can specify when deploying resources.",
    "metadata": {
      "category": "General"
    },
    "parameters": {
      "allowedLocations": {
        "type": "Array",
        "metadata": {
          "description": "The list of allowed locations for resources.",
          "displayName": "Allowed locations",
          "strongType": "location"
        }
      }
    },
    "policyRule": {
      "if": {
        "not": {
          "field": "location",
          "in": "[parameters('allowedLocations')]"
        }
      },
      "then": {
        "effect": "deny"
      }
    }
  }
}
```

#### ステップ2: アーキタイプに追加

```yaml title="lib/archetype_definitions/root_custom.alz_archetype_override.yaml"
base_archetype: root
name: root_custom
policy_assignments_to_add:
  - Allowed-Locations
policy_definitions_to_add:
  - Allowed-Locations
```

#### ステップ3: パラメータを設定

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  # ...
  policy_default_values = {
    allowed_locations = ["japaneast", "japanwest"]
  }
}
```

### パターン2: 既存ポリシーの無効化

**シナリオ**: DDoS Protection Planが未作成なので、DDoSポリシーを一時的に無効化したい

```yaml title="lib/archetype_definitions/connectivity_custom.alz_archetype_override.yaml"
base_archetype: connectivity
name: connectivity_custom
policy_assignments_to_remove:
  - Enable-DDoS-VNET  # コメントアウトを外す
```

または、監査モードに変更：

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  # ...
  policy_assignments_to_modify = {
    connectivity = {
      policy_assignments = {
        Enable-DDoS-VNET = {
          enforcement_mode = "DoNotEnforce"
        }
      }
    }
  }
}
```

### パターン3: サブスクリプションの配置

**シナリオ**: 新しいサブスクリプションを管理グループに配置したい

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  # ...
  subscription_placement = {
    my_new_subscription = {
      subscription_id       = "12345678-1234-1234-1234-123456789012"
      management_group_name = "corp"
    }
  }
}
```

### パターン4: ポリシーパラメータの変更

**シナリオ**: Microsoft Defenderの設定を変更したい

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  # ...
  policy_assignments_to_modify = {
    alz = {
      policy_assignments = {
        Deploy-MDFC-Config-H224 = {
          parameters = {
            emailSecurityContact = "security@example.com"
            enableAscForServers = "DeployIfNotExists"
            enableAscForStorage = "Disabled"  # Storageの保護を無効化
          }
        }
      }
    }
  }
}
```

### パターン5: カスタムロールの追加

**シナリオ**: 特定の管理グループに対してカスタムロールを割り当てたい

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  # ...
  management_group_role_assignments = {
    platform_owner = {
      management_group_name      = "platform"
      role_definition_id_or_name = "Owner"
      principal_id               = "12345678-1234-1234-1234-123456789012"
      description                = "Platform team owner access"
    }
  }
}
```

---

## まとめ

このChapterでは、管理グループとポリシーの完全な実装を解説しました。

**学んだこと**:

1. **管理グループ階層**: ALZの推奨構造とポリシー継承の仕組み
2. **設定ファイル**: platform-landing-zone.auto.tfvarsの全533行の意味
3. **main.management.tf**: countパターンとmovedブロックによる状態管理
4. **lib/フォルダ**: YAMLによる階層構造とポリシーの定義
5. **locals.tf**: 依存関係の管理と設定の変換
6. **ローカルモジュール**: データ変換とパラメータ整形
7. **公式モジュール**: Azure公式モジュールの内部構造
8. **実践パターン**: よくあるカスタマイズ方法

**次のChapter**:

Chapter 09では、管理リソース（Log Analytics、Automation Account、Data Collection Rules）の実装を解説します。

