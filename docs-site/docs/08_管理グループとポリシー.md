# Chapter 08: 管理グループとポリシー

このChapterでは、Azure Landing Zonesの心臓部である**管理グループ階層**と**ポリシーアーキテクチャ**を解説します。

main.management.tfで管理グループを作成し、YAMLファイルでポリシーを定義して、階層全体にガバナンスを適用する流れを完全に理解しましょう。

---

## Part 1: 管理グループとは何か？

### 管理グループの役割

管理グループは、複数のサブスクリプションをグループ化して、ポリシーやロールベースアクセス制御（RBAC）を一元管理するための仕組みです。

**具体例で理解**：

```
Tenant Root（テナントルート）
└── alz（ALZルート）
    ├── platform（プラットフォーム）
    │   ├── management（管理）
    │   ├── connectivity（接続）
    │   └── identity（ID）
    └── landingzones（ランディングゾーン）
        ├── corp（企業）
        └── online（オンライン）
```

- **alz**: すべての管理グループの親
- **platform**: 共通インフラ（ログ、ネットワーク、ID）
- **landingzones**: アプリケーション環境（本番、開発など）

### ポリシー継承の仕組み

管理グループに適用したポリシーは、配下のすべての管理グループとサブスクリプションに自動的に継承されます。

!!! tip "ポリシー継承の利点"
    - **alz**に適用したポリシーは全環境に適用される
    - **platform**に適用したポリシーは管理/接続/ID環境にのみ適用
    - **corp**に適用したポリシーは企業アプリにのみ適用

この継承構造により、組織全体のガバナンスを効率的に管理できます。

---

## Part 2: main.management.tfの全体像

まずは実際のファイルを見てみましょう。

```hcl title="main.management.tf（完全版）"
# Management Groups & Policies
# This file deploys the management group hierarchy and associated Azure Policy resources.
# The Azure Landing Zone portal accelerator originally authored this resource.

# Module: Management Groups & Policies
# Source: https://github.com/Azure/terraform-azurerm-avm-ptn-alz
# Version: 0.14.1
module "management_groups" {
  source  = "Azure/avm-ptn-alz/azurerm"
  version = "0.14.1"

  # Architecture
  architecture_name      = local.config.management_group_settings.architecture_name
  parent_resource_id     = local.config.management_group_settings.root_management_group_id
  location               = local.config.management_group_settings.location
  enable_telemetry       = local.config.management_group_settings.enable_telemetry

  # Dependencies
  dependencies = {
    management_groups = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
    policy_assignments = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
    policy_role_assignments = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
  }

  # Policy Settings
  policy_default_values        = var.management_group_settings.policy_default_values != null ? local.policy_default_values : null
  policy_assignments_to_modify = var.management_group_settings.policy_assignments_to_modify

  # Resource API Versions
  resource_api_versions = var.management_group_settings.resource_api_versions

  # Retries Configuration
  retries = var.management_group_settings.retries

  # Timeouts Configuration
  timeouts = var.management_group_settings.timeouts

  # Subscription Placement
  subscription_placement = var.management_group_settings.subscription_placement
}

# Moved Blocks for Terraform State Migration
moved {
  from = module.alz
  to   = module.management_groups
}
```

### このファイルの3つの役割

1. **管理グループ階層の作成**
2. **ポリシー定義・割り当ての作成**
3. **既存Terraform stateからの移行（moved block）**

### 使用しているモジュール

**公式モジュール**: `Azure/avm-ptn-alz/azurerm` v0.14.1

このモジュールは、Azure Landing Zonesのリファレンス実装を提供する公式Terraformモジュールです。

**GitHubリポジトリ**:

https://github.com/Azure/terraform-azurerm-avm-ptn-alz

**Terraform Registry**:

https://registry.terraform.io/modules/Azure/avm-ptn-alz/azurerm/0.14.1

!!! info "公式モジュールを使う理由"
    - Microsoftが公式にメンテナンス
    - ベストプラクティスが組み込まれている
    - 定期的にアップデート（新しいポリシー追加など）

---

## Part 3: 設定ファイルの完全解説

管理グループの設定は、`platform-landing-zone.auto.tfvars`で定義します。533行の大規模ファイルですが、体系的に理解していきましょう。

### ファイル構造の全体像

```hcl title="platform-landing-zone.auto.tfvars（構造）"
management_group_settings = {
  # 1. 基本設定（行1-7）
  architecture_name              = "alz"
  root_management_group_id       = "alz"
  location                       = "swedencentral"
  enable_telemetry               = true
  
  # 2. ポリシーデフォルト値（行9-30）
  policy_default_values = {
    # 管理リソースの設定
    ama_change_tracking_data_collection_rule_id         = "placeholder"
    ama_mdfc_sql_defender_data_collection_rule_id       = "placeholder"
    ama_vm_insights_data_collection_rule_id             = "placeholder"
    automation_account_resource_id                      = "placeholder"
    log_analytics_workspace_resource_id                 = "placeholder"
    
    # 接続リソースの設定
    ddos_protection_plan_resource_id                    = "placeholder"
    private_dns_zone_subscription_id                    = "placeholder"
    private_dns_zone_region                             = "swedencentral"
    private_dns_zone_resource_group_name                = "placeholder"
    
    # セキュリティ設定
    email_security_contact                              = "security_contact@replace_me"
    microsoft_defender_for_cloud_email_security_contact = "security_contact@replace_me"
  }
  
  # 3. ポリシー割り当て変更（行32-65）
  policy_assignments_to_modify = {
    connectivity = {
      policy_assignments = {
        Enable-DDoS-VNET = {
          enforcement_mode = "DoNotEnforce"
        }
      }
    }
  }
  
  # 4. API バージョン（行67-73）
  resource_api_versions = {}
  
  # 5. リトライ設定（行75-231）
  retries = {
    management_group = {}
    policy_definitions = {}
    policy_set_definitions = {}
    policy_assignments = {}
    policy_role_assignments = {}
    role_assignments = {}
    role_definitions = {}
  }
  
  # 6. タイムアウト設定（行233-319）
  timeouts = {
    management_group = {}
    policy_assignment = {}
    policy_definition = {}
    policy_role_assignment = {}
    policy_set_definition = {}
    role_assignment = {}
    role_definition = {}
  }
  
  # 7. サブスクリプション配置（行321-323）
  subscription_placement = {}
}
```

### 1. 基本設定の解説

```hcl title="基本設定"
architecture_name              = "alz"
root_management_group_id       = "alz"
location                       = "swedencentral"
enable_telemetry               = true
```

**各パラメータの意味**:

- `architecture_name`: YAMLファイル名（`lib/architecture_definitions/alz_custom.alz_architecture_definition.yaml`）
- `root_management_group_id`: ルート管理グループのID（通常は"alz"）
- `location`: ポリシーマネージドIDのデフォルトリージョン
- `enable_telemetry`: Microsoftに使用統計を送信するか（匿名化済み）

### 2. ポリシーデフォルト値の解説

ポリシーには**パラメータ**があり、環境ごとに異なる値を設定できます。

**管理リソースのパラメータ**:

```hcl title="管理リソース設定"
ama_change_tracking_data_collection_rule_id         = "placeholder"
ama_mdfc_sql_defender_data_collection_rule_id       = "placeholder"
ama_vm_insights_data_collection_rule_id             = "placeholder"
automation_account_resource_id                      = "placeholder"
log_analytics_workspace_resource_id                 = "placeholder"
```

これらは、Azure Monitor Agent（AMA）やLog Analyticsワークスペースを指定するためのパラメータです。

!!! warning "placeholderの意味"
    - 初期値は`"placeholder"`（ダミー値）
    - 実際のリソースIDに置き換える必要がある
    - Chapter 09で実際のリソースを作成後に更新

**接続リソースのパラメータ**:

```hcl title="接続リソース設定"
ddos_protection_plan_resource_id                    = "placeholder"
private_dns_zone_subscription_id                    = "placeholder"
private_dns_zone_region                             = "swedencentral"
private_dns_zone_resource_group_name                = "placeholder"
```

これらは、DDoS保護やプライベートDNSゾーンを指定するパラメータです。

**セキュリティ設定**:

```hcl title="セキュリティ連絡先"
email_security_contact                              = "security_contact@replace_me"
microsoft_defender_for_cloud_email_security_contact = "security_contact@replace_me"
```

セキュリティアラートの送信先メールアドレスです。

### 3. ポリシー割り当て変更の解説

特定のポリシーを無効化したり、パラメータを上書きしたりできます。

```hcl title="ポリシー割り当て変更"
policy_assignments_to_modify = {
  connectivity = {
    policy_assignments = {
      Enable-DDoS-VNET = {
        enforcement_mode = "DoNotEnforce"
      }
    }
  }
}
```

**この設定の意味**:

- **connectivity**管理グループに割り当てられた**Enable-DDoS-VNET**ポリシーを無効化
- `enforcement_mode = "DoNotEnforce"`: ポリシーは評価されるが強制されない（監査モード）

**使いどころ**:

- DDoS Protection Planが未作成の場合に一時的に無効化
- 段階的なポリシー適用（まず監査、後で強制）

### 4. API バージョン設定

各AzureリソースのAPIバージョンを指定できます。

```hcl title="API バージョン"
resource_api_versions = {}
```

!!! info "デフォルト値"
    空の場合、モジュール内のデフォルト値が使用されます。
    特殊な要件がない限り変更不要。

### 5. リトライ設定の詳細

Azure APIの一時的なエラーに対するリトライ設定です。

```hcl title="リトライ設定例"
retries = {
  management_group = {
    error_message_regex = [
      "AuthorizationFailed",
    ]
    interval_seconds     = 5
    max_interval_seconds = 30
    multiplier           = 1.5
    randomization_factor = 0.5
  }
  # 他のリソースも同様...
}
```

**パラメータの意味**:

- `error_message_regex`: リトライするエラーメッセージのパターン
- `interval_seconds`: 初回リトライまでの待機時間（秒）
- `max_interval_seconds`: 最大待機時間（秒）
- `multiplier`: 待機時間の増加倍率（指数バックオフ）
- `randomization_factor`: 待機時間のランダム化係数

**なぜリトライが必要か**:

Azure APIは、特に管理グループ作成直後に一時的なエラーを返すことがあります。

- **AuthorizationFailed**: 管理グループ作成直後にGETできない（結果整合性）
- **PolicyDefinitionNotFound**: ポリシー定義作成直後に割り当てできない

リトライ機能により、これらの一時的なエラーを自動的に解決できます。

### 6. タイムアウト設定の詳細

各リソースのTerraform操作のタイムアウト時間を設定します。

```hcl title="タイムアウト設定例"
timeouts = {
  management_group = {
    create = "60m"
    delete = "60m"
    read   = "5m"
    update = "60m"
  }
  policy_assignment = {
    create = "60m"
    delete = "60m"
    read   = "5m"
    update = "60m"
  }
  # 他のリソースも同様...
}
```

**大規模環境での注意点**:

管理グループ階層が深い場合や、ポリシー定義が多い場合は、デフォルトのタイムアウトでは不足する可能性があります。

### 7. サブスクリプション配置

作成した管理グループにサブスクリプションを配置できます。

```hcl title="サブスクリプション配置"
subscription_placement = {}
```

!!! info "空の場合"
    サブスクリプションは配置されません。
    後からAzureポータルやTerraformで配置可能。

---

## Part 4: YAMLファイルによるポリシー定義

Azure Landing Zonesでは、ポリシーを**YAML形式**で定義します。このアプローチにより、ポリシーのバージョン管理とレビューが容易になります。

### libフォルダの構造

```
lib/
├── alz_library_metadata.json
├── architecture_definitions/
│   └── alz_custom.alz_architecture_definition.yaml  # 管理グループ階層定義
└── archetype_definitions/
    ├── connectivity_custom.alz_archetype_override.yaml
    ├── corp_custom.alz_archetype_override.yaml
    ├── decommissioned_custom.alz_archetype_override.yaml
    ├── identity_custom.alz_archetype_override.yaml
    ├── landing_zones_custom.alz_archetype_override.yaml
    ├── management_custom.alz_archetype_override.yaml
    ├── online_custom.alz_archetype_override.yaml
    ├── platform_custom.alz_archetype_override.yaml
    ├── root_custom.alz_archetype_override.yaml
    ├── sandbox_custom.alz_archetype_override.yaml
    └── security_custom.alz_archetype_override.yaml
```

### ファイルの役割

**1. Architecture Definition（管理グループ階層定義）**

`alz_custom.alz_architecture_definition.yaml`で、管理グループの階層構造を定義します。

```yaml title="lib/architecture_definitions/alz_custom.alz_architecture_definition.yaml"
name: alz
management_groups:
  - id: alz
    display_name: ALZ Root
    parent_id: null
    archetypes:
      - root

  - id: platform
    display_name: Platform
    parent_id: alz
    archetypes:
      - platform

  - id: management
    display_name: Management
    parent_id: platform
    archetypes:
      - management

  - id: connectivity
    display_name: Connectivity
    parent_id: platform
    archetypes:
      - connectivity

  - id: identity
    display_name: Identity
    parent_id: platform
    archetypes:
      - identity

  - id: landingzones
    display_name: Landing Zones
    parent_id: alz
    archetypes:
      - landing_zones

  - id: corp
    display_name: Corp
    parent_id: landingzones
    archetypes:
      - corp

  - id: online
    display_name: Online
    parent_id: landingzones
    archetypes:
      - online

  - id: sandbox
    display_name: Sandbox
    parent_id: alz
    archetypes:
      - sandbox

  - id: security
    display_name: Security
    parent_id: alz
    archetypes:
      - security

  - id: decommissioned
    display_name: Decommissioned
    parent_id: alz
    archetypes:
      - decommissioned
```

**このファイルで定義すること**:

- 管理グループのID（`id`）
- 表示名（`display_name`）
- 親管理グループ（`parent_id`）
- 適用するアーキタイプ（`archetypes`）

**2. Archetype Override（ポリシー割り当て定義）**

各管理グループに適用するポリシーを、アーキタイプオーバーライドファイルで定義します。

```yaml title="lib/archetype_definitions/root_custom.alz_archetype_override.yaml（例）"
name: root
base_archetype: root

policy_assignments_to_add:
  - Enforce-ALZ-Decomm
  - Deploy-MDFC-Config-H224

policy_assignments_to_remove: []
```

**このファイルで定義すること**:

- `name`: アーキタイプ名（管理グループのarchetypesと一致）
- `base_archetype`: 継承元のアーキタイプ（公式ライブラリから）
- `policy_assignments_to_add`: 追加するポリシー割り当て
- `policy_assignments_to_remove`: 削除するポリシー割り当て

!!! info "公式ライブラリとの関係"
    - `base_archetype`で公式ライブラリのアーキタイプを継承
    - `_to_add`と`_to_remove`で差分を定義
    - この方法により、公式アップデート時の変更を最小化

---

## Part 5: 公式モジュールの内部構造と処理フロー

ここからは、`Azure/avm-ptn-alz/azurerm`モジュールの内部コードを詳細に解説します。

### モジュールのファイル構成

```
terraform-azurerm-avm-ptn-alz/
├── main.tf                            # ALZ Providerからデータ取得
├── locals.tf                          # データ変換ロジック
├── main.management_groups.tf          # 管理グループ作成
├── main.policy_definitions.tf         # ポリシー定義作成
├── main.policy_set_definitions.tf     # ポリシーセット定義作成
├── main.policy_assignments.tf         # ポリシー割り当て作成
├── main.policy_role_assignments.tf    # ポリシー用ロール割り当て作成
├── main.role_assignments.tf           # ユーザー用ロール割り当て作成
├── main.role_definitions.tf           # カスタムロール定義作成
├── variables.tf                       # 入力変数定義
├── outputs.tf                         # 出力値定義
└── terraform.tf                       # プロバイダ設定
```

### Step 1: ALZ Providerからのデータ取得

すべての処理は、`main.tf`の`data "alz_architecture"`から始まります。

```hcl title="main.tf"
data "alz_architecture" "this" {
  name                         = var.architecture_name
  root_management_group_id     = var.parent_resource_id
  location                     = var.location
  policy_assignments_to_modify = var.policy_assignments_to_modify
  policy_default_values        = var.policy_default_values

  override_policy_definition_parameter_assign_permissions_set   = var.override_policy_definition_parameter_assign_permissions_set
  override_policy_definition_parameter_assign_permissions_unset = var.override_policy_definition_parameter_assign_permissions_unset
}
```

**このdata sourceが何をしているか**:

1. **YAMLファイルの読み込み**
   - `lib/architecture_definitions/`から管理グループ階層を読み込み
   - `lib/archetype_definitions/`からポリシー定義を読み込み

2. **公式ライブラリとのマージ**
   - Azure Landing Zones公式ライブラリ（GitHub）から最新のポリシー定義を取得
   - カスタム定義とマージ

3. **ポリシーパラメータの置換**
   - `policy_default_values`で指定した値をポリシーに適用
   - `policy_assignments_to_modify`で指定した変更を適用

4. **JSON形式への変換**
   - YAMLで定義されたポリシーをAzure REST APIで使用できるJSON形式に変換

!!! info "ALZ Providerの内部処理"
    ALZ Providerは、Go言語で実装されたTerraform Providerです。
    
    主要な処理ロジック（`internal/services/architecture_data_source.go`）:
    
    ```go
    func (d *architectureDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
        // 1. YAMLファイル読み込み
        depl := deployment.NewHierarchy(d.data.AlzLib)
        depl.FromArchitecture(ctx, data.Name.ValueString(), data.RootManagementGroupId.ValueString(), data.Location.ValueString())
        
        // 2. ポリシーデフォルト値の適用
        for defName, defVal := range data.PolicyDefaultValues.Elements() {
            depl.AddDefaultPolicyAssignmentValue(ctx, defName, paramVal)
        }
        
        // 3. ポリシー割り当て変更の適用
        modifyPolicyAssignments(ctx, depl, data, resp)
        
        // 4. ポリシーロール割り当ての生成
        policyRoleAssignments, _ := depl.PolicyRoleAssignments(ctx)
        
        // 5. JSON形式への変換
        for _, mgName := range depl.ManagementGroupNames() {
            mg := depl.ManagementGroup(mgName)
            // management_groups出力に追加
        }
    }
    ```

**出力されるデータ**:

```hcl
data.alz_architecture.this = {
  management_groups = [
    {
      id           = "alz"
      display_name = "ALZ Root"
      parent_id    = "tenant_id"
      level        = 0
      exists       = false
      policy_assignments = {
        "Enforce-ALZ-Decomm" = "{\"name\":\"Enforce-ALZ-Decomm\",\"properties\":{...}}"
        # 他のポリシー割り当て...
      }
      policy_definitions = {
        "Deny-Classic-Resources" = "{\"name\":\"Deny-Classic-Resources\",\"properties\":{...}}"
        # 他のポリシー定義...
      }
      policy_set_definitions = {...}
      role_definitions = {...}
    },
    # 他の管理グループ...
  ]
  policy_role_assignments = [
    {
      policy_assignment_name = "Deploy-ASC-Monitoring"
      role_definition_id     = "/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c"
      scope                  = "/subscriptions/00000000-0000-0000-0000-000000000000"
      management_group_id    = "alz"
    },
    # 他のロール割り当て...
  ]
}
```

### Step 2: ローカル変数でのデータ変換

`locals.tf`で、ALZ Providerから取得したデータを、Azureリソース作成に適した形式に変換します。

```hcl title="locals.tf（主要部分）"
# 管理グループをレベルごとに分類
locals {
  management_groups = { for v in data.alz_architecture.this.management_groups : v.id => {
    id           = v.id
    level        = v.level
    exists       = v.exists
    display_name = v.display_name
    parent_id    = v.parent_id
  } }
  management_groups_level_0 = { for k, v in local.management_groups : k => v if v.level == 0 && !v.exists }
  management_groups_level_1 = { for k, v in local.management_groups : k => v if v.level == 1 && !v.exists }
  management_groups_level_2 = { for k, v in local.management_groups : k => v if v.level == 2 && !v.exists }
  # ...level_6まで
}

# ポリシー定義をマップ形式に変換
locals {
  policy_definitions = {
    for pdval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for pdname, pd in mg.policy_definitions : {
          key        = pdname
          definition = jsondecode(pd)
          mg         = mg.id
        }
      ]
  ]) : "${pdval.mg}/${pdval.key}" => pdval }
}

# ポリシーセット定義をマップ形式に変換
locals {
  policy_set_definitions = {
    for psdval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for psdname, psd in mg.policy_set_definitions : {
          key            = psdname
          set_definition = jsondecode(psd)
          mg             = mg.id
        }
      ]
  ]) : "${psdval.mg}/${psdval.key}" => psdval }
}

# ポリシー割り当てをマップ形式に変換（変更適用後）
locals {
  policy_assignments = {
    for paval in flatten([
      for mg in data.alz_architecture.this.management_groups : [
        for paname, pa in mg.policy_assignments : {
          key        = paname
          assignment = jsondecode(pa)
          mg         = mg.id
        }
      ]
  ]) : "${paval.mg}/${paval.key}" => paval }
  
  policy_assignments_final = {
    for k, v in local.policy_assignments : k => {
      mg         = v.mg
      assignment = merge(v.assignment, local.policy_assignments_properties_final[k])
    }
  }
}

# ポリシーロール割り当てをマップ形式に変換
locals {
  policy_role_assignments = data.alz_architecture.this.policy_role_assignments != null ? {
    for pra in data.alz_architecture.this.policy_role_assignments : uuidv5("url", "${pra.policy_assignment_name}${pra.scope}${pra.management_group_id}${pra.role_definition_id}") => {
      principal_id       = lookup(local.policy_assignment_identities, "${pra.management_group_id}/${pra.policy_assignment_name}", tostring(null))
      role_definition_id = startswith(lower(pra.scope), "/subscriptions") ? "/subscriptions/${split("/", pra.scope)[2]}${pra.role_definition_id}" : pra.role_definition_id
      scope              = pra.scope
    } if !strcontains(pra.scope, "00000000-0000-0000-0000-000000000000")
  } : {}
}
```

**データ変換の目的**:

1. **階層的な作成順序の実現**
   - `management_groups_level_0`から順番に作成
   - 親管理グループが存在しないとエラーになるため

2. **一意なキーの生成**
   - `"${mg_id}/${policy_name}"`形式のキーでリソースを管理
   - Terraform stateでの一意性を保証

3. **JSON文字列からオブジェクトへの変換**
   - ALZ Providerは JSON文字列として返す
   - `jsondecode()`でTerraformオブジェクトに変換

### Step 3: 管理グループの作成

`main.management_groups.tf`で、管理グループを階層的に作成します。

```hcl title="main.management_groups.tf（主要部分）"
# 依存関係の管理
resource "terraform_data" "management_groups_dependencies" {
  input = sha256(jsonencode(var.dependencies.management_groups))
}

# レベル0（ルート直下）の管理グループ
resource "azapi_resource" "management_groups_level_0" {
  for_each = local.management_groups_level_0

  name      = each.value.id
  parent_id = "/"
  type      = "Microsoft.Management/managementGroups@2023-04-01"
  body = {
    properties = {
      details = {
        parent = {
          id = "/providers/Microsoft.Management/managementGroups/${each.value.parent_id}"
        }
      }
      displayName = each.value.display_name
    }
  }
  create_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers   = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  replace_triggers_external_values = [
    each.value.parent_id,
  ]
  response_export_values = []
  retry = var.retries.management_group.error_message_regex != null ? {
    error_message_regex  = var.retries.management_group.error_message_regex
    interval_seconds     = lookup(var.retries.management_group, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.management_group, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.management_group, "multiplier", null)
    randomization_factor = lookup(var.retries.management_group, "randomization_factor", null)
  } : null
  schema_validation_enabled = var.schema_validation_enabled.management_groups
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.management_group.create
    delete = var.timeouts.management_group.delete
    read   = var.timeouts.management_group.read
    update = var.timeouts.management_group.update
  }

  depends_on = [
    terraform_data.management_groups_dependencies,
  ]
}

# レベル1-6も同様の構造で作成
# level_1 depends_on level_0
# level_2 depends_on level_1
# ...
```

**重要なポイント**:

1. **階層的な依存関係**
   - `depends_on`で前のレベルの完了を待つ
   - レベル0→レベル1→レベル2の順に作成

2. **Azure REST APIの直接使用**
   - `azapi_resource`でAzure Management APIを直接呼び出し
   - `type = "Microsoft.Management/managementGroups@2023-04-01"`

3. **リトライ機能**
   - `retry`ブロックで一時的なエラーを自動リトライ
   - `error_message_regex = ["AuthorizationFailed"]`

4. **テレメトリ**
   - `User-Agent`ヘッダーで使用統計を送信（匿名化）

### Step 4: ポリシー定義の作成

`main.policy_definitions.tf`で、カスタムポリシー定義を作成します。

```hcl title="main.policy_definitions.tf"
resource "azapi_resource" "policy_definitions" {
  for_each = local.policy_definitions

  name      = each.value.definition.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_definitions, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policyDefinitions@2023-04-01"
  body = {
    properties = each.value.definition.properties
  }
  create_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers           = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  response_export_values = []
  retry = var.retries.policy_definitions.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_definitions.error_message_regex
    interval_seconds     = lookup(var.retries.policy_definitions, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_definitions, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_definitions, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_definitions, "randomization_factor", null)
  } : null
  schema_validation_enabled = var.schema_validation_enabled.policy_definitions
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_definition.create
    delete = var.timeouts.policy_definition.delete
    read   = var.timeouts.policy_definition.read
    update = var.timeouts.policy_definition.update
  }

  depends_on = [
    azapi_resource.management_groups_level_0,
    azapi_resource.management_groups_level_1,
    azapi_resource.management_groups_level_2,
    azapi_resource.management_groups_level_3,
    azapi_resource.management_groups_level_4,
    azapi_resource.management_groups_level_5,
    azapi_resource.management_groups_level_6,
  ]
}
```

**ポリシー定義のJSON構造**:

```json
{
  "name": "Deny-Classic-Resources",
  "properties": {
    "displayName": "Deny deployment of classic resources",
    "policyType": "Custom",
    "mode": "All",
    "description": "This policy denies deployment of classic resources",
    "metadata": {
      "version": "1.0.0",
      "category": "General"
    },
    "policyRule": {
      "if": {
        "anyOf": [
          {
            "field": "type",
            "like": "Microsoft.ClassicCompute/*"
          },
          {
            "field": "type",
            "like": "Microsoft.ClassicStorage/*"
          }
        ]
      },
      "then": {
        "effect": "Deny"
      }
    }
  }
}
```

### Step 5: ポリシーセット定義の作成

`main.policy_set_definitions.tf`で、複数のポリシーをグループ化したポリシーセット（イニシアティブ）を作成します。

```hcl title="main.policy_set_definitions.tf"
resource "azapi_resource" "policy_set_definitions" {
  for_each = local.policy_set_definitions

  name      = each.value.set_definition.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_set_definitions, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policySetDefinitions@2023-04-01"
  body = {
    properties = each.value.set_definition.properties
  }
  create_headers                   = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers                   = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers                     = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  replace_triggers_external_values = lookup(each.value.set_definition.properties, "policyType", null)
  response_export_values           = []
  retry = var.retries.policy_set_definitions.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_set_definitions.error_message_regex
    interval_seconds     = lookup(var.retries.policy_set_definitions, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_set_definitions, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_set_definitions, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_set_definitions, "randomization_factor", null)
  } : null
  schema_validation_enabled = var.schema_validation_enabled.policy_set_definitions
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_set_definition.create
    delete = var.timeouts.policy_set_definition.delete
    read   = var.timeouts.policy_set_definition.read
    update = var.timeouts.policy_set_definition.update
  }

  depends_on = [
    azapi_resource.policy_definitions,
  ]
}
```

**ポリシーセットの構造**:

```json
{
  "name": "Deploy-Diagnostics-LogAnalytics",
  "properties": {
    "displayName": "Deploy Diagnostic Settings to Azure Services",
    "policyType": "Custom",
    "description": "This policy set deploys diagnostic settings for Azure services to Log Analytics",
    "metadata": {
      "version": "1.0.0",
      "category": "Monitoring"
    },
    "policyDefinitions": [
      {
        "policyDefinitionId": "/providers/Microsoft.Management/managementGroups/alz/providers/Microsoft.Authorization/policyDefinitions/Deploy-Diagnostics-VM",
        "parameters": {
          "logAnalytics": {
            "value": "[parameters('logAnalytics')]"
          }
        }
      },
      {
        "policyDefinitionId": "/providers/Microsoft.Management/managementGroups/alz/providers/Microsoft.Authorization/policyDefinitions/Deploy-Diagnostics-VNET",
        "parameters": {
          "logAnalytics": {
            "value": "[parameters('logAnalytics')]"
          }
        }
      }
    ]
  }
}
```

### Step 6: ポリシー割り当ての作成

`main.policy_assignments.tf`で、管理グループにポリシーを割り当てます。

```hcl title="main.policy_assignments.tf"
resource "terraform_data" "policy_assignments_dependencies" {
  input = sha256(jsonencode(var.dependencies.policy_assignments))
}

resource "azapi_resource" "policy_assignments" {
  for_each = local.policy_assignments_final

  location  = var.location
  name      = each.value.assignment.name
  parent_id = "${coalesce(lookup(var.parent_id_overrides.policy_assignments, each.key, null), "/providers/Microsoft.Management/managementGroups")}/${each.value.mg}"
  type      = "Microsoft.Authorization/policyAssignments@2024-04-01"
  body = {
    properties = {
      description       = lookup(each.value.assignment.properties, "description", null)
      definitionVersion = lookup(each.value.assignment.properties, "definitionVersion", "1.*.*")
      displayName       = lookup(each.value.assignment.properties, "displayName", null)
      enforcementMode   = lookup(each.value.assignment.properties, "enforcementMode", null)
      metadata = merge(lookup(each.value.assignment.properties, "metadata", {}),
        {
          createdBy = ""
          createdOn = ""
          updatedBy = ""
          updatedOn = ""
        }
      )
      nonComplianceMessages = lookup(each.value.assignment.properties, "nonComplianceMessages", null)
      notScopes             = lookup(each.value.assignment.properties, "notScopes", null)
      overrides             = lookup(each.value.assignment.properties, "overrides", null)
      parameters            = lookup(each.value.assignment.properties, "parameters", null)
      policyDefinitionId    = lookup(each.value.assignment.properties, "policyDefinitionId", null)
      resourceSelectors     = lookup(each.value.assignment.properties, "resourceSelectors", null)
    }
  }
  create_headers          = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers          = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  ignore_missing_property = true
  read_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  replace_triggers_external_values = [
    lookup(each.value.assignment.properties, "policyDefinitionId", null),
    var.location,
  ]
  response_export_values = ["identity"]
  retry = var.retries.policy_assignments.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_assignments.error_message_regex
    interval_seconds     = lookup(var.retries.policy_assignments, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_assignments, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_assignments, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_assignments, "randomization_factor", null)
  } : null
  schema_validation_enabled = var.schema_validation_enabled.policy_assignments
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  # Identity block
  dynamic "identity" {
    for_each = lookup(each.value.assignment, "identity", null) != null ? [1] : []
    content {
      type         = each.value.assignment.identity.type
      identity_ids = try(keys(each.value.assignment.identity.userAssignedIdentities), [])
    }
  }

  timeouts {
    create = var.timeouts.policy_assignment.create
    delete = var.timeouts.policy_assignment.delete
    read   = var.timeouts.policy_assignment.read
    update = var.timeouts.policy_assignment.update
  }

  depends_on = [
    azapi_resource.policy_set_definitions,
    terraform_data.policy_assignments_dependencies,
  ]
}
```

**ポリシー割り当ての重要な機能**:

1. **マネージドID**
   - `identity`ブロックでSystemAssignedまたはUserAssigned IDを指定
   - DeployIfNotExistsやModifyポリシーに必要

2. **パラメータ**
   - `parameters`でポリシーのパラメータを指定
   - `policy_default_values`で指定した値が適用済み

3. **強制モード**
   - `enforcementMode`で"Default"または"DoNotEnforce"を指定
   - "DoNotEnforce"は監査のみ（強制しない）

### Step 7: ポリシー用ロール割り当ての作成

`main.policy_role_assignments.tf`で、ポリシーのマネージドIDに必要な権限を付与します。

```hcl title="main.policy_role_assignments.tf"
resource "terraform_data" "policy_role_assignments_dependencies" {
  input = sha256(jsonencode(var.dependencies.policy_role_assignments))
}

data "azapi_resource" "policy_user_assigned_identities" {
  for_each = local.policy_assignments_user_assigned_identity

  resource_id = each.value[0]
  type        = "Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31"
  response_export_values = [
    "properties.principalId",
  ]

  depends_on = [
    terraform_data.policy_role_assignments_dependencies,
    terraform_data.policy_assignments_dependencies,
  ]
}

resource "azapi_resource" "policy_role_assignments" {
  for_each = local.policy_role_assignments

  name      = each.key
  parent_id = each.value.scope
  type      = "Microsoft.Authorization/roleAssignments@2022-04-01"
  body = {
    properties = {
      principalId      = each.value.principal_id
      roleDefinitionId = each.value.role_definition_id
      description      = "Created by ALZ Terraform provider. Assignment required for Azure Policy."
    }
  }
  create_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers   = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  retry = var.retries.policy_role_assignments.error_message_regex != null ? {
    error_message_regex  = var.retries.policy_role_assignments.error_message_regex
    interval_seconds     = lookup(var.retries.policy_role_assignments, "interval_seconds", null)
    max_interval_seconds = lookup(var.retries.policy_role_assignments, "max_interval_seconds", null)
    multiplier           = lookup(var.retries.policy_role_assignments, "multiplier", null)
    randomization_factor = lookup(var.retries.policy_role_assignments, "randomization_factor", null)
  } : null
  schema_validation_enabled = var.schema_validation_enabled.policy_role_assignments
  update_headers            = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null

  timeouts {
    create = var.timeouts.policy_role_assignment.create
    delete = var.timeouts.policy_role_assignment.delete
    read   = var.timeouts.policy_role_assignment.read
    update = var.timeouts.policy_role_assignment.update
  }

  depends_on = [
    azapi_resource.policy_assignments,
    terraform_data.policy_role_assignments_dependencies,
  ]
}
```

**ロール割り当ての仕組み**:

1. **principalIdの取得**
   - ポリシー割り当てのマネージドIDのprincipalIdを取得
   - SystemAssignedの場合は`azapi_resource.policy_assignments.identity.principal_id`
   - UserAssignedの場合は`data.azapi_resource.policy_user_assigned_identities`

2. **scopeの決定**
   - ALZ Providerが`policy_role_assignments`で出力したscopeを使用
   - ポリシー定義のメタデータ`assignPermissions`から自動計算

3. **roleDefinitionIdの決定**
   - ポリシーが必要とするロール（Contributor、Storage Blob Data Contributorなど）
   - ポリシー定義のメタデータから自動計算

!!! info "assignPermissionsメタデータ"
    ポリシー定義のparametersセクションに、以下のようなメタデータを記載することで、ALZ Providerが自動的にロール割り当てを生成します。
    
    ```json
    "parameters": {
      "logAnalytics": {
        "type": "String",
        "metadata": {
          "displayName": "Log Analytics workspace",
          "description": "Log Analytics workspace resource ID",
          "assignPermissions": true
        }
      }
    }
    ```

---

## Part 6: modules/management_groups/の内部構造

このプロジェクトでは、公式モジュールをさらにラップした`modules/management_groups/`を使用しています。

### モジュールの役割

`modules/management_groups/`は、以下の役割を持ちます：

1. **変数の簡略化**
   - 公式モジュールの複雑な変数を簡潔な形式に変換
   - ユーザーが使いやすいインターフェースを提供

2. **ローカル変数での前処理**
   - JSONエンコードが必要な値を事前処理
   - 依存関係の整理

3. **出力値の整理**
   - 必要な出力値のみを公開

### ファイル構成

```
modules/management_groups/
├── main.tf           # 公式モジュールの呼び出し
├── variables.tf      # 入力変数定義（256行）
├── locals.tf         # 前処理ロジック（14行）
├── outputs.tf        # 出力値定義
└── terraform.tf      # プロバイダ設定
```

### variables.tfの詳細

`variables.tf`では、管理グループ設定のすべてのパラメータを定義しています。

```hcl title="modules/management_groups/variables.tf（主要部分）"
variable "management_group_settings" {
  type = object({
    architecture_name        = string
    root_management_group_id = string
    location                 = string
    enable_telemetry         = bool
    
    policy_default_values = optional(map(string), null)
    
    policy_assignments_to_modify = optional(map(object({
      policy_assignments = map(object({
        enforcement_mode = optional(string, null)
        identity         = optional(string, null)
        identity_ids     = optional(list(string), null)
        parameters       = optional(map(string), null)
        non_compliance_messages = optional(set(object({
          message                        = string
          policy_definition_reference_id = optional(string, null)
        })), null)
        resource_selectors = optional(list(object({
          name = string
          resource_selector_selectors = optional(list(object({
            kind   = string
            in     = optional(set(string), null)
            not_in = optional(set(string), null)
          })), [])
        })))
        overrides = optional(list(object({
          kind  = string
          value = string
          override_selectors = optional(list(object({
            kind   = string
            in     = optional(set(string), null)
            not_in = optional(set(string), null)
          })), [])
        })))
      }))
    })))
    
    resource_api_versions = optional(object({
      policy_assignment     = optional(string, "2024-04-01")
      policy_definition     = optional(string, "2023-04-01")
      policy_set_definition = optional(string, "2023-04-01")
      role_assignment       = optional(string, "2022-04-01")
      role_definition       = optional(string, "2022-04-01")
      management_group      = optional(string, "2023-04-01")
    }), {})
    
    retries = optional(object({
      management_group = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed",
        ])
        interval_seconds     = optional(number, null)
        max_interval_seconds = optional(number, null)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      policy_definitions = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed"
        ])
        interval_seconds     = optional(number, null)
        max_interval_seconds = optional(number, null)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      policy_set_definitions = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed"
        ])
        interval_seconds     = optional(number, null)
        max_interval_seconds = optional(number, null)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      policy_assignments = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed",
          "The policy definition specified in policy assignment '.+' is out of scope"
        ])
        interval_seconds     = optional(number, 5)
        max_interval_seconds = optional(number, 30)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      policy_role_assignments = optional(object({
        error_message_regex = optional(list(string), [
          "PrincipalNotFound",
        ])
        interval_seconds     = optional(number, 5)
        max_interval_seconds = optional(number, 30)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      role_assignments = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed",
        ])
        interval_seconds     = optional(number, null)
        max_interval_seconds = optional(number, null)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
      role_definitions = optional(object({
        error_message_regex = optional(list(string), [
          "AuthorizationFailed"
        ])
        interval_seconds     = optional(number, null)
        max_interval_seconds = optional(number, null)
        multiplier           = optional(number, null)
        randomization_factor = optional(number, null)
      }), {})
    }), {})
    
    timeouts = optional(object({
      management_group = optional(object({
        create = optional(string, "60m")
        delete = optional(string, "60m")
        read   = optional(string, "5m")
        update = optional(string, "60m")
      }), {})
      policy_assignment = optional(object({
        create = optional(string, "60m")
        delete = optional(string, "60m")
        read   = optional(string, "5m")
        update = optional(string, "60m")
      }), {})
      policy_definition = optional(object({
        create = optional(string, "30m")
        delete = optional(string, "30m")
        read   = optional(string, "5m")
        update = optional(string, "30m")
      }), {})
      policy_role_assignment = optional(object({
        create = optional(string, "30m")
        delete = optional(string, "30m")
        read   = optional(string, "5m")
        update = optional(string, "30m")
      }), {})
      policy_set_definition = optional(object({
        create = optional(string, "30m")
        delete = optional(string, "30m")
        read   = optional(string, "5m")
        update = optional(string, "30m")
      }), {})
      role_assignment = optional(object({
        create = optional(string, "30m")
        delete = optional(string, "30m")
        read   = optional(string, "5m")
        update = optional(string, "30m")
      }), {})
      role_definition = optional(object({
        create = optional(string, "30m")
        delete = optional(string, "30m")
        read   = optional(string, "5m")
        update = optional(string, "30m")
      }), {})
    }), {})
    
    subscription_placement = optional(map(object({
      subscription_id       = string
      management_group_name = string
    })), {})
  })
  
  description = <<DESCRIPTION
Settings for the management group module.

This object describes the management group settings. It includes the following attributes:

- `architecture_name`: The name of the architecture to deploy. This is used to identify the architecture definition file.
- `root_management_group_id`: The root management group id under which to deploy the architecture.
- `location`: The Azure region used as a default for resources.
- `enable_telemetry`: Enable telemetry for the module.

- `policy_default_values`: A map of default values to apply to policy assignments.
- `policy_assignments_to_modify`: A map of policy assignment objects to modify the ALZ architecture with.

- `resource_api_versions`: A map of resource API versions to use for each resource type.

- `retries`: Retry configuration for Azure API operations.
  - `management_group`: Retry configuration for management group operations.
  - `policy_definitions`: Retry configuration for policy definition operations.
  - `policy_set_definitions`: Retry configuration for policy set definition operations.
  - `policy_assignments`: Retry configuration for policy assignment operations.
  - `policy_role_assignments`: Retry configuration for policy role assignment operations.
  - `role_assignments`: Retry configuration for role assignment operations.
  - `role_definitions`: Retry configuration for role definition operations.

- `timeouts`: Timeout configuration for Terraform operations.
  - `management_group`: Timeout configuration for management group operations.
  - `policy_assignment`: Timeout configuration for policy assignment operations.
  - `policy_definition`: Timeout configuration for policy definition operations.
  - `policy_role_assignment`: Timeout configuration for policy role assignment operations.
  - `policy_set_definition`: Timeout configuration for policy set definition operations.
  - `role_assignment`: Timeout configuration for role assignment operations.
  - `role_definition`: Timeout configuration for role definition operations.

- `subscription_placement`: A map of subscriptions to place into management groups.
DESCRIPTION
  nullable    = false
}
```

**変数定義の特徴**:

1. **optionalの多用**
   - ほとんどのパラメータがoptional
   - デフォルト値が設定されている
   - ユーザーは必要な部分だけ上書き可能

2. **ネストされたオブジェクト構造**
   - `retries.management_group.error_message_regex`のような深いネスト
   - 体系的な整理で理解しやすい

3. **詳細なdescription**
   - 各パラメータの用途を明確に記載
   - ユーザーが設定を理解しやすい

### locals.tfの前処理ロジック

`locals.tf`では、JSONエンコードが必要な値を事前処理します。

```hcl title="modules/management_groups/locals.tf"
locals {
  # Encode policy default values if provided
  policy_default_values = var.management_group_settings.policy_default_values != null ? {
    for k, v in var.management_group_settings.policy_default_values :
    k => jsonencode({ value = v })
  } : null

  # Encode policy assignments to modify parameters if provided
  policy_assignments_to_modify = var.management_group_settings.policy_assignments_to_modify != null ? {
    for mgk, mgv in var.management_group_settings.policy_assignments_to_modify :
    mgk => {
      policy_assignments = {
        for pak, pav in mgv.policy_assignments :
        pak => merge(pav, pav.parameters != null ? {
          parameters = { for pk, pv in pav.parameters : pk => jsonencode({ value = pv }) }
        } : {})
      }
    }
  } : {}
}
```

**前処理の役割**:

1. **policy_default_values**
   - ユーザー入力: `"placeholder"`
   - 変換後: `"{\"value\":\"placeholder\"}"`
   - Azure Policy APIで要求されるJSON形式に変換

2. **policy_assignments_to_modify**
   - ユーザー入力: `parameters = { metricsEnabled = false }`
   - 変換後: `parameters = { metricsEnabled = "{\"value\":false}" }`
   - 同様にJSON形式に変換

!!! warning "なぜJSONエンコードが必要か"
    Azure Policy APIは、パラメータ値を常にJSON形式で受け取ります。
    
    ```json
    {
      "parameters": {
        "logAnalytics": {
          "value": "/subscriptions/.../resourceGroups/.../providers/Microsoft.OperationalInsights/workspaces/myworkspace"
        }
      }
    }
    ```
    
    Terraformの型システムと統合するため、ユーザーは文字列や数値で指定し、モジュール内でJSON形式に変換します。

### main.tfでの公式モジュール呼び出し

`main.tf`で、前処理済みの値を公式モジュールに渡します。

```hcl title="modules/management_groups/main.tf"
module "management_groups" {
  source  = "Azure/avm-ptn-alz/azurerm"
  version = "0.14.1"

  # Basic settings
  architecture_name      = var.management_group_settings.architecture_name
  parent_resource_id     = var.management_group_settings.root_management_group_id
  location               = var.management_group_settings.location
  enable_telemetry       = var.management_group_settings.enable_telemetry

  # Policy settings (pre-processed)
  policy_default_values        = local.policy_default_values
  policy_assignments_to_modify = local.policy_assignments_to_modify

  # Advanced settings
  resource_api_versions  = var.management_group_settings.resource_api_versions
  retries                = var.management_group_settings.retries
  timeouts               = var.management_group_settings.timeouts
  subscription_placement = var.management_group_settings.subscription_placement

  # Dependencies (passed from root module)
  dependencies = var.dependencies
}
```

---

## Part 7: ルートlocals.tfでの依存関係管理

ルートの`locals.tf`では、モジュール間の依存関係を管理します。

```hcl title="locals.tf（依存関係部分）"
locals {
  # Management Group Dependencies
  management_group_dependencies = {
    management_groups = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
    policy_assignments = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
    policy_role_assignments = [
      module.resource_groups.created_time,
      module.config_templating.config.current_time,
    ]
  }
}
```

**依存関係の意味**:

1. **管理グループ作成の依存**
   - リソースグループが作成された後
   - 設定テンプレートの処理が完了した後

2. **ポリシー割り当ての依存**
   - 同じく、事前リソースの作成完了を待つ

3. **ロール割り当ての依存**
   - ポリシーのマネージドIDが作成された後

!!! tip "依存関係管理のベストプラクティス"
    Terraformの`depends_on`だけでは不十分な場合があります。
    
    - 計算された値（computed value）を依存関係に使う
    - `created_time`や`current_time`のような一意な値
    - 値が変わると、依存先も再作成される

---

## Part 8: 実践パターン

### パターン1: カスタムポリシーの追加

新しいポリシーを追加したい場合の手順です。

**ステップ1: YAML定義を追加**

```yaml title="lib/archetype_definitions/root_custom.alz_archetype_override.yaml"
name: root
base_archetype: root

policy_assignments_to_add:
  - Enforce-ALZ-Decomm
  - Deploy-MDFC-Config-H224
  - My-Custom-Policy  # 追加

policy_assignments_to_remove: []
```

**ステップ2: ポリシー定義ファイルを作成**

公式ライブラリの形式に従って、YAMLまたはJSON形式でポリシー定義を作成します。

詳細は公式ドキュメントを参照：

https://azure.github.io/Azure-Landing-Zones-Library/

**ステップ3: Terraform適用**

```bash
terraform plan
terraform apply
```

### パターン2: ポリシーパラメータの更新

管理リソース作成後、実際のリソースIDに更新します。

**ステップ1: リソースIDの取得**

```bash
# Log Analytics ワークスペースのIDを取得
az monitor log-analytics workspace show \
  --resource-group rg-management \
  --workspace-name law-management \
  --query id -o tsv
```

**ステップ2: 設定ファイルの更新**

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  policy_default_values = {
    log_analytics_workspace_resource_id = "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-management/providers/Microsoft.OperationalInsights/workspaces/law-management"
  }
}
```

**ステップ3: Terraform適用**

```bash
terraform plan
terraform apply
```

!!! warning "注意：既存のポリシー割り当ては更新されない"
    `policy_default_values`の変更は、**新規**ポリシー割り当てにのみ適用されます。
    
    既存のポリシー割り当てを更新するには、`policy_assignments_to_modify`を使用します。

### パターン3: ポリシーの無効化（監査モード）

特定のポリシーを一時的に無効化します。

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  policy_assignments_to_modify = {
    connectivity = {
      policy_assignments = {
        Enable-DDoS-VNET = {
          enforcement_mode = "DoNotEnforce"
        }
      }
    }
  }
}
```

### パターン4: サブスクリプションの配置

作成した管理グループにサブスクリプションを配置します。

```hcl title="platform-landing-zone.auto.tfvars"
management_group_settings = {
  subscription_placement = {
    sub1 = {
      subscription_id       = "00000000-0000-0000-0000-000000000001"
      management_group_name = "corp"
    }
    sub2 = {
      subscription_id       = "00000000-0000-0000-0000-000000000002"
      management_group_name = "online"
    }
  }
}
```

---

## Part 9: トラブルシューティング

### 問題1: AuthorizationFailedエラー

**エラーメッセージ**:

```
Error: creating Management Group: authorization failed: AuthorizationFailed
```

**原因**:

管理グループ作成直後のGET操作が失敗（結果整合性）

**解決策**:

リトライ設定を確認します。デフォルトで有効なので、通常は自動解決されます。

```hcl title="確認"
retries = {
  management_group = {
    error_message_regex = [
      "AuthorizationFailed",
    ]
  }
}
```

### 問題2: Policy assignment not foundエラー

**エラーメッセージ**:

```
Error: The policy definition specified in policy assignment 'XXX' is out of scope
```

**原因**:

ポリシー定義が作成される前にポリシー割り当てが実行された

**解決策**:

リトライ設定でこのエラーも対象にします。

```hcl title="platform-landing-zone.auto.tfvars"
retries = {
  policy_assignments = {
    error_message_regex = [
      "AuthorizationFailed",
      "The policy definition specified in policy assignment '.+' is out of scope"
    ]
    interval_seconds     = 5
    max_interval_seconds = 30
  }
}
```

### 問題3: Timeout during apply

**エラーメッセージ**:

```
Error: timeout while waiting for state to become 'success'
```

**原因**:

大規模な管理グループ階層でタイムアウト

**解決策**:

タイムアウト時間を延長します。

```hcl title="platform-landing-zone.auto.tfvars"
timeouts = {
  management_group = {
    create = "120m"  # 2時間
    update = "120m"
  }
  policy_assignment = {
    create = "120m"
    update = "120m"
  }
}
```

### 問題4: PrincipalNotFoundエラー

**エラーメッセージ**:

```
Error: Principal XXXX does not exist in the directory
```

**原因**:

ポリシー割り当てのマネージドIDが作成直後で、まだAzure ADに反映されていない

**解決策**:

リトライ設定でこのエラーも対象にします（デフォルトで有効）。

```hcl title="確認"
retries = {
  policy_role_assignments = {
    error_message_regex = [
      "PrincipalNotFound",
    ]
    interval_seconds     = 5
    max_interval_seconds = 30
  }
}
```

---

## Part 10: FAQ

### Q1: 管理グループの削除順序は？

**A**: Terraformが自動的に逆順で削除します。

1. ロール割り当て
2. ポリシー割り当て
3. ポリシーセット定義
4. ポリシー定義
5. 管理グループ（レベル6→レベル0）

### Q2: 既存の管理グループをインポートできる？

**A**: はい、可能です。

```bash
terraform import 'module.management_groups.azapi_resource.management_groups_level_0["alz"]' '/providers/Microsoft.Management/managementGroups/alz'
```

### Q3: 公式ライブラリのアップデート方法は？

**A**: Azure Landing Zones Libraryは、GitHubでバージョン管理されています。

新しいバージョンがリリースされたら、以下を実行します：

```bash
# プロバイダのアップデート
terraform init -upgrade

# 変更の確認
terraform plan

# 適用
terraform apply
```

### Q4: 複数のAzure環境に対応できる？

**A**: はい、Terraform Workspaceまたは異なるstateファイルで管理できます。

```bash
# 本番環境
terraform workspace new prod
terraform apply -var-file="prod.tfvars"

# 開発環境
terraform workspace new dev
terraform apply -var-file="dev.tfvars"
```

### Q5: ポリシーの監査結果はどこで見る？

**A**: Azure Portalの「Policy」サービスで確認できます。

- コンプライアンス状態
- 非準拠リソースの一覧
- ポリシー効果の履歴

### Q6: カスタムポリシーと組み込みポリシーの違いは？

**A**:

- **組み込みポリシー**: Microsoftが提供、自動アップデート
- **カスタムポリシー**: 自分で定義、バージョン管理が必要

Azure Landing Zonesでは、組み込みポリシーを基に、カスタムポリシーセットを作成しています。

### Q7: ポリシーの強制モード（Enforcement Mode）の使い分けは？

**A**:

- **Default**: ポリシーを強制（作成/更新を拒否）
- **DoNotEnforce**: 監査のみ（コンプライアンス状態を記録、強制しない）

段階的な適用には、まず"DoNotEnforce"で影響を確認してから"Default"に変更します。

### Q8: policy_default_valuesとpolicy_assignments_to_modifyの違いは？

**A**:

- **policy_default_values**: すべてのポリシー割り当てのデフォルト値
- **policy_assignments_to_modify**: 特定のポリシー割り当ての上書き

`policy_default_values`は、YAMLで定義されたプレースホルダーを置き換えます。
`policy_assignments_to_modify`は、既存のポリシー割り当ての設定を変更します。

### Q9: リトライ機能が効かない場合は？

**A**: 以下を確認してください：

1. エラーメッセージがリトライ対象か
2. `max_interval_seconds`が十分な長さか
3. Azure APIのレート制限に達していないか

### Q10: 管理グループ階層を変更する場合の注意点は？

**A**: 階層変更は慎重に行ってください。

- **親管理グループの変更**: ポリシー継承が変わる
- **管理グループの削除**: 配下のサブスクリプションは親に移動
- **管理グループのリネーム**: IDは変更不可、表示名のみ変更可能

変更前に、必ず`terraform plan`で影響を確認してください。

---

## まとめ

この章では、Azure Landing Zonesの管理グループとポリシーアーキテクチャを完全に解説しました。

**重要なポイント**:

1. **階層構造**: 管理グループ階層でガバナンスを一元管理
2. **YAML定義**: ポリシーをYAMLで定義し、バージョン管理
3. **公式モジュール**: Azure公式モジュールで標準的な構成を実現
4. **カスタマイズ**: 組織のニーズに合わせて柔軟にカスタマイズ可能
5. **自動化**: Terraformで管理グループとポリシーを自動デプロイ

次のChapterでは、管理リソース（Log Analytics、Automation Account）を作成し、実際のリソースIDをポリシーパラメータに設定します。
