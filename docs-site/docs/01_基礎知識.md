# 01. 基礎知識 - Terraform・Azure・Landing Zones入門

!!! info "この章で学ぶこと"
    このプロジェクトを理解するために必要な基礎知識を学びます：

    1. Terraformって何？
    2. Azureの基本概念
    3. Azure Landing Zonesの設計思想
    4. Infrastructure as Codeの考え方

    すでに知ってる内容もあるかもしれませんが、復習のつもりでサラッと読んでください。

---

## Part 1: Terraformって何？

### 「コードでインフラを作る」とは？

=== "昔のやり方"

    ```text title="オンプレミス時代"
    1. データセンターに行く
    2. ラックからサーバーを取り出す
    3. ケーブルを繋ぐ
    4. OSをインストール
    5. 設定ファイルを手で編集
    ```

=== "今のやり方（クラウド）"

    ```text title="Azureポータルでの作成"
    1. Azureポータルにログイン
    2. 「仮想マシン」をクリック
    3. フォームに入力（名前、サイズ、場所...）
    4. 「作成」ボタンをクリック
    ```

!!! warning "でも、これって問題がある"
    - 間違えやすい（入力ミス）
    - 再現できない（どう作ったか忘れる）
    - 時間がかかる（10個作るなら10回やる）

そこでTerraform。コードでインフラを定義します：

```hcl title="Terraformでの定義"
resource "azurerm_virtual_machine" "example" {
  name                = "my-vm"
  location            = "japaneast"
  size                = "Standard_B2s"
  # ...その他の設定
}
```

このコードを実行すると、VMが作られます。

!!! success "コードで管理するメリット"
    - バージョン管理できる（Git）
    - レビューできる
    - 再利用できる
    - 自動化できる

### Terraformの3つのステップ

Terraformは3ステップで動きます：

#### 1. Write（書く）
```hcl title="main.tf"
resource "azurerm_resource_group" "example" {
  name     = "my-rg"
  location = "japaneast"
}
```

#### 2. Plan（計画）
```bash title="実行前の確認"
$ terraform plan
# Terraform will perform the following actions:
#   + azurerm_resource_group.example
#       name:     "my-rg"
#       location: "japaneast"
```

「これから何を作るか」を教えてくれます。

#### 3. Apply（適用）
```bash title="実際に作成"
$ terraform apply
# 本当に実行してもいい？ (yes/no): yes
# Creating...
# Creation complete!
```

実際にAzureにリソースが作られます。

### Terraformの賢いところ

#### 差分管理
Terraformは「現在の状態」を覚えています。

```hcl title="設定の変更例"
# 最初はこう書いた
resource "azurerm_resource_group" "example" {
  name     = "my-rg"
  location = "japaneast"
}

# 後で場所を変更
resource "azurerm_resource_group" "example" {
  name     = "my-rg"
  location = "japanwest"  # ← 変更
}
```

`terraform apply`すると：

- リソースグループを削除して
- 新しい場所に作り直す

Terraformが賢く判断してくれます。

#### 依存関係の解決
```hcl title="依存関係の自動解決"
resource "azurerm_resource_group" "rg" {
  name     = "my-rg"
  location = "japaneast"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "my-vnet"
  resource_group_name = azurerm_resource_group.rg.name  # ← 依存
  location            = azurerm_resource_group.rg.location
  address_space       = ["10.0.0.0/16"]
}
```

VNetを作る前に、RGを作る必要があります。  
Terraformが自動で順序を判断してくれます。

### HCLの基本文法

TerraformはHCL（HashiCorp Configuration Language）で書きます。

#### ブロック構造
```hcl title="HCLの基本構造"
<ブロックタイプ> "<ラベル>" "<名前>" {
  <引数> = <値>
}
```

例：
```hcl
resource "azurerm_resource_group" "example" {
  name     = "my-rg"
  location = "japaneast"
}
```

- `resource`: リソースを定義
- `"azurerm_resource_group"`: リソースのタイプ
- `"example"`: Terraform内での識別名
- `name`, `location`: 引数

#### データ型
```hcl
# 文字列
name = "my-resource"

# 数値
count = 3

# 真偽値
enabled = true

# リスト
locations = ["japaneast", "japanwest"]

# マップ
tags = {
  environment = "prod"
  team        = "platform"
}
```

#### 変数参照
```hcl
# 変数定義
variable "location" {
  default = "japaneast"
}

# 変数使用
resource "azurerm_resource_group" "rg" {
  name     = "my-rg"
  location = var.location  # ← var.で参照
}
```

#### 他のリソース参照
```hcl
resource "azurerm_resource_group" "rg" {
  name     = "my-rg"
  location = "japaneast"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "my-vnet"
  resource_group_name = azurerm_resource_group.rg.name  # ← 他のリソースを参照
  location            = azurerm_resource_group.rg.location
}
```

---

## Part 2: Azureの基本概念

### Azureの階層構造

Azureは階層構造で管理されています：

```
Azure AD（認証の大元）
└── Tenant（テナント = 会社全体）
    └── Management Groups（管理グループ = 部署みたいなもの）
        └── Subscriptions（サブスクリプション = 予算枠）
            └── Resource Groups（リソースグループ = プロジェクト）
                └── Resources（リソース = 実際のサーバーとか）
```

#### 1. Tenant（テナント）
会社全体。普通は1社1テナント。

#### 2. Management Groups（管理グループ）
部署みたいなもの。階層構造で管理できます：

```
本社
├── 開発本部
│   ├── WebアプリチームSubscription
│   └── モバイルアプリチームSubscription
└── インフラ本部
    ├── ネットワークSubscription
    └── セキュリティSubscription
```

管理グループにポリシーを適用すると、配下の全サブスクリプションに継承されます。

#### 3. Subscriptions（サブスクリプション）
予算枠。月末に請求が来ます。  
プロジェクトや環境ごとに分けるのが一般的：

- 本番環境用Subscription
- 開発環境用Subscription
- 検証環境用Subscription

#### 4. Resource Groups（リソースグループ）
リソースを束ねる入れ物。  
「このプロジェクトで使うリソースは全部ここ」みたいに使います。

特徴：

- 同じリージョンでなくてもOK（リソースグループのリージョンと中のリソースのリージョンは揃えてね）
- まとめて削除できる
- まとめて権限管理できる

#### 5. Resources（リソース）
実際のVM、VNet、Storageなど。

### Azureの重要な概念

#### Location（リージョン）
Azureのデータセンターの場所。日本だと：

- `japaneast`（東日本 = 埼玉・東京）
- `japanwest`（西日本 = 大阪）

リージョンによって：

- 使えるサービスが違う
- 価格が違う
- 物理的に離れているので災害対策になる

#### Availability Zones（可用性ゾーン）
1つのリージョン内の複数のデータセンター。  
例: 東日本リージョン内に3つのゾーン（Zone 1, 2, 3）

**重要**: 日本リージョンは全てのサービスでAvailability Zonesをサポートしてません！  
このプロジェクトでハマったポイントです。

#### Resource Provider
Azureのサービス提供者。例：

- `Microsoft.Network`: VNet, Firewallなど
- `Microsoft.Compute`: VMなど
- `Microsoft.Storage`: ストレージ

### Azure Policy

Azureの「会社のルール」を強制する仕組み。

例：
```json
{
  "if": {
    "field": "type",
    "equals": "Microsoft.Network/publicIPAddresses"
  },
  "then": {
    "effect": "deny"
  }
}
```

「Public IPは作っちゃダメ」というルール。  
違反しようとすると、Azureが止めてくれます。

#### Policyの3要素

1. **Policy Definition**（ポリシー定義）  
   ルールそのもの。「こうしなさい」「これダメ」

2. **Policy Set Definition**（ポリシーセット定義）  
   複数のポリシーをまとめたもの。「セキュリティ基準セット」とか。イニシアティブともいう。

3. **Policy Assignment**（ポリシー割り当て）  
   管理グループやサブスクリプションに適用する。

#### Policyの効果（Effect）

- `Deny`: 拒否。作れない。
- `Audit`: 警告。作れるけど記録される。
- `Append`: 追加。タグを自動で付けるとか。
- `Modify`: 修正。設定を自動で変更。
- `DeployIfNotExists`: 無ければ作る。

---

## Part 3: Azure Landing Zonesの設計思想

### Landing Zonesって何？

Microsoftが定義した「企業向けAzure環境のベストプラクティス」です。

**なぜLanding Zonesが必要なのか？**

いきなりAzureでアプリを作り始めると、こんな問題が起きます：

!!! warning "よくある失敗例"
    1. **リソースがバラバラ** → 「あのVMどのRGに入れたっけ？」
    2. **セキュリティが甘い** → 「Public IP全開で本番デプロイしちゃった…」
    3. **コストが見えない** → 「今月の請求、なんで500万円！？」
    4. **権限がめちゃくちゃ** → 「開発者が本番環境を削除できちゃう」
    5. **監視してない** → 「障害に3日気づかなかった」

Landing Zonesは、こういう問題を最初から防ぐ仕組みです。

#### 飛行機の例で理解しよう

飛行機の例で言うと：

- **滑走路** = Subscription（アプリが動く場所）
- **管制塔** = Management Groups + Policy（誰が何をしていいか管理）
- **整備場** = Log Analytics（監視・メンテナンス）
- **セキュリティゲート** = Firewall（出入り口の検査）
- **誘導灯** = Private DNS（どこに行けばいいか案内）

全部揃っているから、アプリケーションが「安全に着陸」できる。

**Landing Zonesがないと？**

```
整備場なし → 故障しても気づかない
管制塔なし → 誰でも好き勝手に飛べる（危険！）
セキュリティゲートなし → テロリストも入り放題
```

怖いですよね。だから最初から「ちゃんとした環境」を作るんです。

### Landing Zonesの8つの設計領域

Microsoftは8つの設計領域を定義しています。  
このプロジェクトは、**これら全てを実装しています**。

#### 1. Azure Billing and Active Directory Tenant（課金とテナント）

**何を決めるか？**
- 誰がお金を払うか
- どうやって認証するか
- 契約形態はどうするか

**具体的には：**

```text title="組織構造の例"
組織構造の例：

ABC株式会社
├── Azure AD Tenant: abc.onmicrosoft.com
├── Enrollment Account（EA契約）
│   └── 請求先: 経理部
└── 部門別に予算配分
    ├── 開発部門: 月500万円まで
    ├── 本番環境: 月1000万円まで
    └── 検証環境: 月100万円まで
```

**このプロジェクトでは：**
- 1つのAzure ADテナント
- サブスクリプションIDを変数で管理
- 複数サブスクリプションに対応可能

**よくある質問：**

- Q: 複数テナント作れる？

- A: 作れるけど、1社1テナントを強く推奨します。理由は後からテナントをまとめるのがすごく大変だからです。あと、entra ID P2のライセンスが二重でかかったり、DefenderやAzureポリシーのガバナンスが分かれちゃったり。

#### 2. Identity and Access Management（ID・アクセス管理）

**何を決めるか？**

- 誰が何をできるか（RBAC）
- どうやってログインするか（MFA、Conditional Access）
- サービスアカウントの管理

**具体的には：**

```text title="役割の例"

【本番環境】
- 閲覧のみ: 全社員
- デプロイ可能: CI/CDパイプライン（自動）のみ
- 削除可能: インフラ責任者のみ（MFA必須）

【開発環境】
- フル権限: 開発チーム
- 閲覧のみ: プロジェクトマネージャー

【禁止事項】
- Owner権限の付与: インフラ責任者の承認必須
- パスワード認証: 禁止（証明書かManaged Identity使う）
```

**このプロジェクトでは：**

- 管理グループレベルでRBAC設定
- Managed Identity推奨（パスワード不要）
- ポリシーで危険な操作を制限

**ベストプラクティス：**

- 本番環境への手動操作は最小限に
- MFA（多要素認証）は必須
- 定期的に権限を棚卸し

#### 3. Resource Organization（リソースの整理）

**何を決めるか？**
- 管理グループの階層構造
- サブスクリプションの分け方
- リソースグループの命名規則

**具体的には：**

```
このプロジェクトの構造：

Root Management Group
├── Platform（プラットフォーム = 基盤）
│   ├── Management（監視基盤）
│   │   └── Subscription: monitoring
│   ├── Connectivity（ネットワーク基盤）
│   │   └── Subscription: connectivity
│   └── Identity（認証基盤）
│       └── Subscription: identity
└── Landing Zones（ランディングゾーン = アプリ用）
    ├── Corp（社内向けアプリ）
    │   └── Subscription: app-corp-prod
    ├── Online（インターネット公開アプリ）
    │   └── Subscription: app-online-prod
    └── Sandbox（実験用）
        └── Subscription: sandbox-dev
```

**なぜこう分けるか？**

**1. Platform（基盤）は分離**

- 「インフラチーム」が管理
- アプリ開発者は触らせない
- 全社で共有（Firewall、監視等）

**2. Landing Zones（アプリ用）はさらに分ける**

- **Corp**: 社内専用（VPN経由のみ）
- **Online**: インターネット公開（Firewall必須）
- **Sandbox**: 実験用（コスト制限、自動削除）

**3. サブスクリプションで予算管理**

- 1サブスクリプション = 1請求単位
- 「今月このアプリいくら使った？」が見える

**命名規則の例：**



```
リソースグループ:
rg-{用途}-{環境}-{リージョン}
例: rg-web-prod-japaneast

リソース:
{種類}-{用途}-{環境}-{リージョン}
例: vm-web-prod-japaneast-001
```

**このプロジェクトでは：**

- Terraformで自動命名
- テンプレート変数で一括管理
- 全リソースに必須タグ（environment, cost-center等）

#### 4. Network Topology and Connectivity（ネットワーク）

**何を決めるか？**

- ネットワーク構成（Hub-Spoke or Virtual WAN）
- オンプレミスとの接続方法
- IPアドレス設計

**具体的には：**

```text title="Hub-Spoke構成の例"

Hub VNet（10.0.0.0/16）
├── Firewall Subnet（10.0.128.0/26）
├── Gateway Subnet（10.0.1.0/27） ← VPN/ExpressRoute
├── Bastion Subnet（10.0.0.64/26）
└── Peering →

Spoke VNet 1（10.1.0.0/16）← Corp（社内向け）
├── App Subnet（10.1.0.0/24）
└── DB Subnet（10.1.1.0/24）

Spoke VNet 2（10.2.0.0/16）← Online（インターネット向け）
├── App Subnet（10.2.0.0/24）
└── DB Subnet（10.2.1.0/24）

全てのトラフィックがHub経由
  ↓
Firewallで一元管理
```

**オンプレミス接続の選択肢：**

| 接続方法 | 速度 | コスト | 特徴 |
|---------|------|--------|------|
| VPN Gateway | 最大1.25Gbps | ¥40,000/月 | インターネット経由、導入簡単 |
| ExpressRoute | 10Gbps〜 | ¥50,000/月〜 | 専用線、安定、高額 |

**このプロジェクトでは：**

- Hub-Spoke型とVirtual WAN型の両方に対応
- 東日本・西日本の2リージョン構成
- Private DNSで名前解決
- 全トラフィックをFirewallで検査

**よくある失敗：**

- IPアドレスが重複（オンプレと被った）
- Firewall通さずに直接インターネット（危険！）
- リージョン間通信を考えてない

#### 5. Security（セキュリティ）

**何を決めるか？**

- Firewall/WAFの設定
- DDoS対策
- データ暗号化
- 脅威検知

**具体的には：**

```text title="セキュリティの層（Defense in Depth）"

【外側】
1. DDoS Protection
   → 大量アクセス攻撃を防ぐ

2. Azure Firewall
   → 不正な通信をブロック

3. WAF（Web Application Firewall）
   → SQLインジェクション等を防ぐ

【中間】
4. NSG（Network Security Group）
   → サブネット/VM単位でアクセス制御

5. Private Endpoint
   → Storageなどをインターネットから隠す

【内側】
6. Disk Encryption
   → データを暗号化

7. Key Vault
   → パスワードを安全に保管

8. Microsoft Defender for Cloud
   → 脅威を検知・通知
```

**このプロジェクトでは：**

- Azure Firewall Standard（脅威インテリジェンス有効）
- Private DNS Zones（内部名前解決）
- ポリシーで「Public IP禁止」などを強制
- 全リソースのログをLog Analyticsに集約

**ベストプラクティス：**

- 「何も設定しない = 危険」ではなく、「デフォルトで安全」に
- ポリシーで危険な設定を自動ブロック
- 定期的に脆弱性診断

#### 6. Management（管理）

**何を決めるか？**

- 監視・ログ収集
- バックアップ戦略
- 災害対策（DR）

**具体的には：**

```text title="監視の基本"
監視の基本：

【ログ収集】
Log Analytics Workspace
├── Activity Log（誰が何を操作したか）
├── Resource Log（VMの状態、エラー等）
├── Firewall Log（通信記録）
└── Security Log（攻撃検知）

【アラート設定】
- VM停止: 即座に通知
- CPU 90%超: 警告
- 不審なログイン: Slackに通知

【バックアップ】
- VM: 毎日バックアップ、30日保持
- Database: 毎時間バックアップ、7日保持
- Blob Storage: Geo冗長（他リージョンにコピー）
```

**このプロジェクトでは：**

- 東日本リージョンにLog Analytics作成
- Azure Monitor Agentで自動ログ収集
- Automation Account（自動運用タスク用）

**よくある運用シナリオ：**

```text title="障害対応の流れ"
障害発生！

1. Log Analyticsで調査
   query: エラーログを検索

2. 原因特定
   → Firewallが通信をブロックしてた

3. 設定変更
   → Terraformで修正 → apply

4. 記録
   → Gitに履歴が残る
```

#### 7. Governance（ガバナンス）

**何を決めるか？**

- Policyでルールを強制
- タグでリソース管理
- コスト管理

**具体的には：**

```text title="ポリシーの例"
ポリシーの例：

【必須ポリシー】
1. "許可されたリージョン"
   → 東日本・西日本以外はNG

2. "必須タグ"
   → environment, cost-center, owner

3. "Public IP禁止"
   → 勝手にインターネット公開NG

4. "VMサイズ制限"
   → Standard_E64s_v3以上は禁止（高すぎる）

5. "削除ロック"
   → 本番環境は削除禁止

【監査ポリシー】
- "Disk暗号化なし" → 警告
- "古いTLS使用" → 警告
```

**タグ戦略：**

```text title="タグ戦略"
必須タグ:
- environment: prod / dev / staging
- cost-center: 部署コード
- owner: 責任者のメールアドレス
- project: プロジェクト名

使い道:
→ Cost Managementで「部署別コスト」を集計
→ 「このリソース誰の？」がすぐわかる
→ 自動削除対象の判定（dev環境は週末削除等）
```

**このプロジェクトでは：**

- YAMLでポリシー定義（読みやすい）
- 管理グループにポリシーを適用（配下全てに適用）
- Terraformでタグを自動付与

#### 8. Platform Automation and DevOps（自動化）

**何を決めるか？**

- CI/CDパイプライン
- Infrastructure as Code（IaC）
- 自動テスト

**具体的には：**

```text title="自動化の流れ"
自動化の流れ：

【開発フロー】
1. Terraformコードを書く
   └─ feature/add-vm ブランチ

2. Pull Request作成
   └─ GitHub Actionsで自動テスト

3. レビュー・承認
   └─ terraform plan の結果を確認

4. mainブランチにマージ
   └─ 自動でterraform apply

5. デプロイ完了
   └─ Slackに通知

【自動テスト内容】
- ✅ HCL文法チェック（terraform fmt）
- ✅ セキュリティスキャン（tfsec）
- ✅ コスト見積もり（Infracost）
- ✅ ポリシー違反チェック
```

**このプロジェクトでは：**

- GitHub Actionsでパイプライン構築
- Terraform Cloudでステート管理
- Azureへの認証はOIDC（パスワード不要）

**自動化のメリット：**

- 人的ミスが減る
- デプロイが早い（数分）
- 履歴が残る（いつ誰が何を変更したか）
- ロールバック簡単（Gitで戻すだけ）

---

### このプロジェクトは「8つ全部」実装している

| 設計領域 | このプロジェクトの実装 |
|---------|----------------------|
| 1. 課金・テナント | サブスクリプションID管理、EA対応 |
| 2. ID・アクセス管理 | 管理グループでRBAC、Managed Identity |
| 3. リソース整理 | Platform/Landing Zones構造 |
| 4. ネットワーク | Hub-Spoke、2リージョン、Firewall |
| 5. セキュリティ | Firewall、Policy、Private DNS |
| 6. 管理 | Log Analytics、Automation |
| 7. ガバナンス | YAML Policy、タグ戦略 |
| 8. 自動化 | GitHub Actions、Terraform |

つまり、このコードを使えば、Microsoftが推奨する「ちゃんとした企業向けAzure環境」が自動で作れるということです。

### アーキテクチャパターン：どっちを選ぶ？

Azure Landing Zonesには、主に2つのネットワーク構成があります。

#### パターン1: Hub-Spoke型（ハブ・スポーク）

**図解：**

```text title="Hub-Spoke型の構造"
        Hub VNet（中央拠点）
        10.0.0.0/16
        ┌─────────────────┐
        │ Firewall        │← インターネットへの出入口
        │ Bastion         │← 安全なVM接続
        │ VPN Gateway     │← オンプレミス接続
        │ Private DNS     │← 名前解決
        └────────┬────────┘
                 │ VNet Peering
         ┌───────┼───────┐
         │       │       │
      Spoke1  Spoke2  Spoke3
      10.1.x.x 10.2.x.x 10.3.x.x
      │       │       │
    WebApp  API    Database
```

**通信の流れ：**

```text title="Hub-Spoke通信パターン"
例1: VMからインターネットへのアクセス

Spoke1（VM）
  ↓
Hub VNetのFirewall ← ここで検査
  ↓
インターネット

例2: Spoke1からSpoke2への通信

Spoke1（WebApp）
  ↓
Hub VNetのFirewall ← 必ずHub経由
  ↓
Spoke2（API）
```

**メリット：**

- シンプルで理解しやすい
- コストが比較的安い
- 小〜中規模に最適

**デメリット：**

- リージョンまたぎが面倒
- Spoke間通信が必ずHub経由（遅延増える）
- グローバル展開には向かない

**こんな会社に向いてる：**

- 日本国内だけで展開
- 支社が30以下
- 予算が限られている

#### パターン2: Virtual WAN型

**図解：**

```text title="Virtual WAN型の構造"
         Virtual WAN（グローバル）
              │
    ┌─────────┼─────────┐
    │         │         │
  vHub1     vHub2     vHub3
 東日本     西日本     米国
10.0.0.0/16 10.1.0.0/16 10.2.0.0/16
    │         │         │
 ┌──┼──┐   ┌──┼──┐   ┌──┼──┐
Spoke Spoke Spoke Spoke Spoke Spoke
```

**通信の流れ：**

```text title="Virtual WAN通信パターン"
例: 東日本のアプリから米国のDBにアクセス

東日本のSpoke
  ↓
vHub1（東日本）
  ↓ Virtual WANバックボーン（高速・低遅延）
vHub3（米国）
  ↓
米国のSpoke（DB）

※ Hub-Spoke型より設定が簡単で速い！
```

**メリット：**

- グローバル展開が簡単
- リージョン間通信が高速
- 設定がシンプル（Azureが自動で最適化）
- 拠点が増えても管理が楽

**デメリット：**

- コストが高い（Virtual WAN自体の料金）
- 小規模には過剰

**こんな会社に向いてる：**

- 世界中に拠点がある
- 支店が多い（30以上）
- 高速な通信が必要

#### このプロジェクトでは両方使える！

```hcl title="構成切り替え"
# Hub-Spoke型を使う場合
connectivity_type = "hub_and_spoke_vnet"

# Virtual WAN型を使う場合
connectivity_type = "virtual_wan"
```

変数1つ変えるだけで切り替え可能です。

#### どっちを選べばいい？

```text title="選択肢の決定木"
質問に答えてください：

Q1: 海外にも展開する予定がある？
  Yes → Virtual WAN推奨
  No  → Q2へ

Q2: 支社は30個以上ある？
  Yes → Virtual WAN推奨
  No  → Q3へ

Q3: 予算は潤沢にある？
  Yes → Virtual WAN でもOK
  No  → Hub-Spoke推奨

【結論】
- 小規模・国内のみ → Hub-Spoke
- 大規模・グローバル → Virtual WAN
- 迷ったら → Hub-Spokeで始めて、後で移行
```

#### 実際の企業例

**Hub-Spoke型を選んだ企業：**

- スタートアップ（国内向けSaaS）
- 中小企業（社内システムのみ）
- 予算重視のプロジェクト

**Virtual WAN型を選んだ企業：**

- グローバル企業（世界10拠点以上）
- 大規模SaaS（複数リージョンで展開）
- M&Aで増えた拠点の統合

---

## Part 4: Infrastructure as Code (IaC)

### なぜコードで書くのか？

#### 従来の問題点
```text title="手順書の問題"
手順書: サーバー構築手順.docx

1. ポータルにログイン
2. リソースグループ「rg-prod」を作成
3. 場所は「East Japan」を選択
4. ...（省略）...
20. 完了
```

これの問題：

- 人によって解釈が違う
- 手順書が古くなる
- ミスが起きる
- 再現が大変

#### IaCのメリット

**1. 再現性**
```hcl title="再現性の例"
resource "azurerm_resource_group" "prod" {
  name     = "rg-prod"
  location = "japaneast"
}
```

何度実行しても同じ結果。

**2. バージョン管理**
```bash title="Git履歴"
git log
# commit 3: Firewallを追加
# commit 2: VNetのサイズを変更
# commit 1: 初期構築
```

いつ誰が何を変更したかわかる。

**3. レビュー**
```bash title="差分確認"
git diff
# + resource "azurerm_firewall" "fw" {
# +   name = "fw-prod"
# + }
```

変更内容を誰かにチェックしてもらえる。

**4. 自動化**
```yaml title="GitHub Actions"
# GitHub Actions
on: push
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - terraform apply
```

GitにpushしたらFull自動でデプロイ。

**5. ドキュメント**

コード自体がドキュメント。  
「どう作ったか」が明確。

### IaCのベストプラクティス

#### 1. 小さく始める
いきなり全部IaCにしない。  
まずは1つのリソースから。

#### 2. モジュール化
再利用可能な部品に分ける。  
このプロジェクトはモジュール化の良い例。

#### 3. 環境を分ける
```text title="環境の分離"
environments/
├── dev/      # 開発環境
├── staging/  # 検証環境
└── prod/     # 本番環境
```

#### 4. シークレットを含めない
パスワードやAPIキーはコードに書かない。  
環境変数やKey Vaultを使う。

#### 5. Planを必ず見る
`terraform apply`の前に`terraform plan`。  
何が変わるか必ず確認。

---

## Part 5: このプロジェクトで使う技術

### terraform.tfの解説

実際のコードを見てみましょう：

```hcl title="terraform.tf"
terraform {
  required_version = "~> 1.12"
  
  required_providers {
    alz = {
      source  = "Azure/alz"
      version = "0.20.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 4.0"
    }
    azapi = {
      source  = "Azure/azapi"
      version = "~> 2.0"
    }
    local = {
      source  = "hashicorp/local"
      version = "~> 2.5"
    }
  }
  
  backend "azurerm" {}
}
```

#### required_version
```hcl title="バージョン指定"
required_version = "~> 1.12"
```

「Terraform 1.12以上じゃないと動かないよ」という宣言。  
`~> 1.12`は「1.12.x」のこと。1.13や2.0はNG。

#### required_providers

使うプロバイダー（AzureとかAWSとか）を宣言。

**alz**: Azure Landing Zones専用プロバイダー  
**azurerm**: Azure Resource Manager（Azureのメインプロバイダー）  
**azapi**: Azure API直接叩く用（azurermでできないことに使う）  
**local**: ローカルファイル操作用

#### backend
```hcl title="状態ファイルの保存先"
backend "azurerm" {}
```

Terraformの状態ファイル（terraform.tfstate）をどこに保存するか。  
`azurerm`= Azureのストレージに保存。

チームで共有できるし、消えないので安全。

---

## まとめ

この章で学んだこと：

### Terraform
- コードでインフラを定義
- Plan → Apply の2ステップ
- 差分管理と依存関係解決が賢い

### Azure
- 階層構造（Tenant → MG → Sub → RG → Resource）
- Policyでルールを強制
- 日本リージョンはAZ非対応のサービスあり

### Landing Zones
- 企業向けのベストプラクティス
- 8つの設計領域
- Hub-Spoke型 or Virtual WAN型

### IaC
- 再現性・バージョン管理・レビューが可能
- コード自体がドキュメント
- 自動化が簡単

---

## 練習問題

練習問題で理解度チェックだ＾＾

### 問題1
Terraformの`terraform plan`コマンドは何をするコマンドですか？

### 問題2
Azureで「管理グループ」の役割は何ですか？

### 問題3
IaCの最大のメリットを1つ挙げてください。

### 問題4
このプロジェクトで使っているプロバイダーを3つ挙げてください。

---

## 練習問題の答え

### 答え1
`terraform plan`は、Terraformが実際にリソースを変更する前に、「何が作成/変更/削除されるか」を表示するコマンドです。実際には何も変更せず、プレビューだけを見せてくれます。

### 答え2
管理グループは、複数のサブスクリプションをまとめて管理するための階層構造です。ポリシーやアクセス制御を一括で適用でき、組織全体のガバナンスを効率的に実現できます。

### 答え3
IaCの最大のメリットは「再現性」です。同じコードから何度でも同じ環境を作れるため、手作業のミスがなくなり、環境の差異も発生しません。

### 答え4
このプロジェクトで使っているプロバイダーは：

1. **alz** (Azure Landing Zones専用プロバイダー)
2. **azurerm** (Azureリソース管理)
3. **azapi** (最新Azure API対応)

---

## 📋 Terraformコマンド早見表

**基本コマンド（安全なもの）**

| コマンド | 用途 | 危険度 | よく使う |
|----------|------|--------|----------|
| `terraform init` | 初期化（プロバイダーのダウンロード） | 安全 ✅ | 最初に1回 |
| `terraform fmt` | コードを整形（見やすくする） | 安全 ✅ | 毎回 |
| `terraform validate` | 文法チェック | 安全 ✅ | 毎回 |
| `terraform plan` | 変更内容の確認（実行しない） | 安全 ✅ | 毎回 |

**実行コマンド（注意が必要）**

| コマンド | 用途 | 危険度 | 注意点 |
|----------|------|--------|--------|
| `terraform apply` | 変更を実際に適用 | 注意 ⚠️ | plan で確認してから |
| `terraform destroy` | 全リソースを削除 | 危険 🚨 | 本番では絶対ダメ！ |

**その他のコマンド**

| コマンド | 用途 | 危険度 |
|----------|------|--------|
| `terraform show` | 現在の状態を表示 | 安全 ✅ |
| `terraform output` | 出力値を表示 | 安全 ✅ |
| `terraform state list` | 管理中のリソース一覧 | 安全 ✅ |
| `terraform refresh` | 状態を最新に更新 | 注意 ⚠️ |

**📌 基本的な実行の流れ**

```bash title="基本的な実行フロー"
# 1. 最初の1回だけ（初期化）
terraform init

# 2. コードを整形
terraform fmt

# 3. 文法チェック
terraform validate

# 4. 変更内容を確認（何度でもOK）
terraform plan

# 5. 問題なければ実行
terraform apply
# → "yes" と入力

# 6. 結果を確認
terraform show
```

**💡 よくある使い方**

```bash title="開発時の使い方"
# 開発中（変更を確認しながら）
terraform plan
# 問題なし → apply
terraform apply

# デバッグ（詳細ログを見たい）
TF_LOG=DEBUG terraform plan

# 特定のリソースだけ削除
terraform destroy -target=azurerm_resource_group.example

# 状態を確認
terraform state list
terraform state show azurerm_resource_group.example
```

**⚠️ やってはいけないこと**

```bash title="禁止事項"
# ❌ plan せずに apply
terraform apply -auto-approve  # 危険！本番では絶対ダメ

# ❌ state ファイルを直接編集
vim terraform.tfstate  # 壊れる！

# ❌ 複数人で同時に apply
# → State ファイルが壊れる
# → GitHub Actions で排他制御が必要
```

---

## 次のステップ

基礎知識は終わり！  
次は[02_プロジェクト構造.md](./02_プロジェクト構造.md)で、  
このリポジトリのファイル構成を詳しく見ていきます。

---

**所要時間**: 30分  
**難易度**: ★★☆☆☆  
**前**: [00_はじめに.md](./00_はじめに.md)  
**次**: [02_プロジェクト構造.md](./02_プロジェクト構造.md)
